<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Offline EPUB Reader</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        #controls {
            position: sticky;
            top: 0;
            background: white;
            padding: 10px;
            border-bottom: 1px solid #ccc;
            z-index: 100;
        }
        #reader {
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            min-height: 400px;
        }
        #book-content img {
            max-width: 100%;
            height: auto;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
        }
        button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <div id="controls">
        <input type="file" id="epub-file" accept=".epub">
        <button onclick="previousChapter()" id="prev-btn" disabled>Previous</button>
        <button onclick="nextChapter()" id="next-btn" disabled>Next</button>
        <span id="chapter-info"></span>
    </div>
    <div id="reader">
        <div id="book-content">Upload an EPUB file to start reading...</div>
    </div>

    <!-- Include JSZip via CDN (replace this with local script for fully offline use) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        let bookFiles = {};
        let spineItems = [];
        let currentChapterIndex = 0;

        document.getElementById('epub-file').addEventListener('change', handleFileUpload);

        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async function(e) {
                const arrayBuffer = e.target.result;

                // Use JSZip to load the EPUB (which is a ZIP file)
                const zip = new JSZip();
                const unzipped = await zip.loadAsync(arrayBuffer);

                // Reset book data
                bookFiles = {};
                spineItems = [];
                currentChapterIndex = 0;

                // Store all files in memory
                for (const [path, zipEntry] of Object.entries(unzipped.files)) {
                    if (!zipEntry.dir) {
                        bookFiles[path] = await zipEntry.async('blob');
                    }
                }

                // Parse EPUB structure
                await parseEpub();
                displayCurrentChapter();
            };
            reader.readAsArrayBuffer(file);
        }

        async function parseEpub() {
            // Step 1: Read container.xml to find the OPF file
            const containerFile = bookFiles['META-INF/container.xml'];
            if (!containerFile) {
                alert('Invalid EPUB: container.xml not found');
                return;
            }
            const containerText = await blobToText(containerFile);
            const parser = new DOMParser();
            const containerDoc = parser.parseFromString(containerText, 'text/xml');
            const opfPath = containerDoc.querySelector('rootfile')?.getAttribute('full-path');
            if (!opfPath) {
                alert('Invalid EPUB: OPF path not found');
                return;
            }

            // Step 2: Parse the OPF file
            const opfFile = bookFiles[opfPath];
            if (!opfFile) {
                alert('Invalid EPUB: OPF file not found');
                return;
            }
            const opfText = await blobToText(opfFile);
            const opfDoc = parser.parseFromString(opfText, 'text/xml');
            const opfBasePath = opfPath.substring(0, opfPath.lastIndexOf('/')) || '';

            // Step 3: Get the spine (reading order)
            const spine = opfDoc.querySelector('spine');
            const itemRefs = spine.querySelectorAll('itemref');
            const manifestItems = {};
            const manifest = opfDoc.querySelector('manifest');
            manifest.querySelectorAll('item').forEach(item => {
                const id = item.getAttribute('id');
                const href = item.getAttribute('href');
                manifestItems[id] = opfBasePath ? `${opfBasePath}/${href}` : href;
            });

            // Step 4: Populate spine items (chapters)
            itemRefs.forEach(itemRef => {
                const idref = itemRef.getAttribute('idref');
                const href = manifestItems[idref];
                if (href) spineItems.push(href);
            });

            updateNavigation();
        }

        async function displayCurrentChapter() {
            if (spineItems.length === 0 || currentChapterIndex < 0 || currentChapterIndex >= spineItems.length) {
                document.getElementById('book-content').innerHTML = 'No chapters available.';
                return;
            }

            const chapterPath = spineItems[currentChapterIndex];
            const chapterFile = bookFiles[chapterPath];
            if (!chapterFile) {
                document.getElementById('book-content').innerHTML = 'Chapter not found.';
                return;
            }

            const chapterText = await blobToText(chapterFile);
            const chapterBasePath = chapterPath.substring(0, chapterPath.lastIndexOf('/')) || '';

            // Create a sandboxed DOM parser for the chapter content
            const parser = new DOMParser();
            const chapterDoc = parser.parseFromString(chapterText, 'text/html');

            // Handle relative paths for assets (images, styles, etc.)
            chapterDoc.querySelectorAll('img, link').forEach(element => {
                const src = element.getAttribute('src') || element.getAttribute('href');
                if (src && !src.startsWith('http')) {
                    const absPath = chapterBasePath ? `${chapterBasePath}/${src}` : src;
                    const blob = bookFiles[absPath];
                    if (blob) {
                        const url = URL.createObjectURL(blob);
                        if (element.tagName === 'IMG') {
                            element.setAttribute('src', url);
                        } else if (element.tagName === 'LINK') {
                            element.setAttribute('href', url);
                        }
                    }
                }
            });

            // Display the chapter content
            const contentDiv = document.getElementById('book-content');
            contentDiv.innerHTML = '';
            const bodyContent = chapterDoc.querySelector('body')?.innerHTML || 'No content found.';
            contentDiv.innerHTML = bodyContent;

            updateNavigation();
        }

        function updateNavigation() {
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            const chapterInfo = document.getElementById('chapter-info');

            prevBtn.disabled = currentChapterIndex <= 0;
            nextBtn.disabled = currentChapterIndex >= spineItems.length - 1;
            chapterInfo.textContent = `Chapter ${currentChapterIndex + 1} of ${spineItems.length}`;
        }

        function previousChapter() {
            if (currentChapterIndex > 0) {
                currentChapterIndex--;
                displayCurrentChapter();
            }
        }

        function nextChapter() {
            if (currentChapterIndex < spineItems.length - 1) {
                currentChapterIndex++;
                displayCurrentChapter();
            }
        }

        async function blobToText(blob) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.readAsText(blob);
            });
        }
    </script>
</body>
</html>