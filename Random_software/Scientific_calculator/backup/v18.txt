import math
import sympy as sp
from fractions import Fraction
import scipy.stats as stats
import numpy as np

def display_menu():
    print("\n" + "="*50)
    print("Scientific Calculator".center(50))
    print("="*50)
    print("1. Basic Operations")
    print("2. Trigonometric Functions")
    print("3. Logarithms/Exponentials")
    print("4. Matrix Operations")
    print("5. Equation Solver")
    print("6. Integral Calculator")
    print("7. Number Inverse")
    print("8. Decimal to Fraction")
    print("9. Inverse Trigonometric Functions")
    print("10. Square and Square Root")
    print("11. Power and Nth Root")
    print("12. Maxima/Minima Calculator")
    print("13. Statistical Functions")
    print("14. Normal-Lognormal Calculations")
    print("15. Combinations, Permutations, and Factorial")
    print("16. Exit")
    print("="*50)


def stats_functions():
    print("\n" + "="*50)
    print("Statistical Functions".center(50))
    print("="*50)
    print("1. Normal Distribution")
    print("2. Binomial Distribution")
    print("3. Poisson Distribution")
    print("4. Exponential Distribution")
    print("5. Uniform Distribution")
    print("6. Geometric Distribution")
    print("="*50)
    
    choice = input("Enter choice (1-6): ")
    
    if choice == '1':
        normal_dist()
    elif choice == '2':
        binomial_dist()
    elif choice == '3':
        poisson_dist()
    elif choice == '4':
        exponential_dist()
    elif choice == '5':
        uniform_dist()
    elif choice == '6':
        geometric_dist()
    else:
        print("Invalid choice")

def geometric_dist():
    print("\n" + "="*50)
    print("Geometric Distribution".center(50))
    print("="*50)
    print("1. PMF")
    print("2. CDF")
    print("3. 1 - CDF")
    print("="*50)
    
    choice = input("Enter choice (1-3): ")
    
    p = float(input("Enter probability of success: "))
    k = int(input("Enter number of trials until first success: "))
    
    if choice == '1':
        result = stats.geom.pmf(k, p)
        print(f"PMF at k = {k}: {result}")
    elif choice == '2':
        result = stats.geom.cdf(k, p)
        print(f"CDF at k = {k}: {result}")
    elif choice == '3':
        result = 1 - stats.geom.cdf(k, p)
        print(f"1 - CDF at k = {k}: {result}")
    else:
        print("Invalid choice")

def normal_dist():
    print("\n" + "="*50)
    print("Normal Distribution".center(50))
    print("="*50)
    print("1. PDF")
    print("2. CDF")
    print("3. 1 - CDF")
    print("4. Z-score")
    print("5. X from Z-score")
    print("6. CDF/PDF/1-CDF from Z-score")
    print("="*50)
    
    choice = input("Enter choice (1-6): ")
    
    if choice != '6':
      mean = float(input("Enter mean: "))
      std_dev = float(input("Enter standard deviation: "))
    
    if choice in ['1', '2', '3']:
        x = float(input("Enter x: "))
        if choice == '1':
            result = stats.norm.pdf(x, mean, std_dev)
            print(f"PDF at x = {x}: {result}")
        elif choice == '2':
            result = stats.norm.cdf(x, mean, std_dev)
            print(f"CDF at x = {x}: {result}")
        elif choice == '3':
            result = 1 - stats.norm.cdf(x, mean, std_dev)
            print(f"1 - CDF at x = {x}: {result}")
    elif choice == '4':
        percentile = float(input("Enter percentile: "))
        result = stats.norm.ppf(percentile, mean, std_dev)
        print(f"Z-score for percentile {percentile}: {result}")
    elif choice == '5':
        z_score = float(input("Enter Z-score: "))
        result = mean + (z_score * std_dev)
        print(f"X for Z-score {z_score}: {result}")
    elif choice == '6':
        z_score = float(input("Enter Z-score: "))
        pdf_result = stats.norm.pdf(z_score)
        print(f"PDF: {pdf_result}")
        cdf_result = stats.norm.cdf(z_score)
        print(f"CDF: {cdf_result}")
        inv_cdf_result = 1 - stats.norm.cdf(z_score)
        print(f"1 - CDF: {inv_cdf_result}")
    else:
        print("Invalid choice")

def binomial_dist():
    print("\n" + "="*50)
    print("Binomial Distribution".center(50))
    print("="*50)
    print("1. PMF")
    print("2. CDF")
    print("3. 1 - CDF")
    print("="*50)
    
    choice = input("Enter choice (1-3): ")
    
    n = int(input("Enter number of trials: "))
    p = float(input("Enter probability of success: "))
    k = int(input("Enter number of successes: "))
    
    if choice == '1':
        result = stats.binom.pmf(k, n, p)
        print(f"PMF at k = {k}: {result}")
    elif choice == '2':
        result = stats.binom.cdf(k, n, p)
        print(f"CDF at k = {k}: {result}")
    elif choice == '3':
        result = 1 - stats.binom.cdf(k, n, p)
        print(f"1 - CDF at k = {k}: {result}")
    else:
        print("Invalid choice")

def poisson_dist():
    print("\n" + "="*50)
    print("Poisson Distribution".center(50))
    print("="*50)
    print("1. PMF")
    print("2. CDF")
    print("3. 1 - CDF")
    print("="*50)
    
    choice = input("Enter choice (1-3): ")
    
    mu = float(input("Enter mean: "))
    k = int(input("Enter number of occurrences: "))
    
    if choice == '1':
        result = stats.poisson.pmf(k, mu)
        print(f"PMF at k = {k}: {result}")
    elif choice == '2':
        result = stats.poisson.cdf(k, mu)
        print(f"CDF at k = {k}: {result}")
    elif choice == '3':
        result = 1 - stats.poisson.cdf(k, mu)
        print(f"1 - CDF at k = {k}: {result}")
    else:
        print("Invalid choice")

def exponential_dist():
    print("\n" + "="*50)
    print("Exponential Distribution".center(50))
    print("="*50)
    print("1. PDF")
    print("2. CDF")
    print("3. 1 - CDF")
    print("="*50)
    
    choice = input("Enter choice (1-3): ")
    
    scale = float(input("Enter scale parameter: "))
    x = float(input("Enter x: "))
    
    if choice == '1':
        result = stats.expon.pdf(x, scale=scale)
        print(f"PDF at x = {x}: {result}")
    elif choice == '2':
        result = stats.expon.cdf(x, scale=scale)
        print(f"CDF at x = {x}: {result}")
    elif choice == '3':
        result = 1 - stats.expon.cdf(x, scale=scale)
        print(f"1 - CDF at x = {x}: {result}")
    else:
        print("Invalid choice")


def uniform_dist():
    print("\n" + "="*50)
    print("Uniform Distribution".center(50))
    print("="*50)
    print("1. PDF")
    print("2. CDF")
    print("3. 1 - CDF")
    print("="*50)
    
    choice = input("Enter choice (1-3): ")
    
    low = float(input("Enter lower bound: "))
    high = float(input("Enter upper bound: "))
    x = float(input("Enter x: "))
    
    if choice == '1':
        result = stats.uniform.pdf(x, loc=low, scale=high-low)
        print(f"PDF at x = {x}: {result}")
    elif choice == '2':
        result = stats.uniform.cdf(x, loc=low, scale=high-low)
        print(f"CDF at x = {x}: {result}")
    elif choice == '3':
        result = 1 - stats.uniform.cdf(x, loc=low, scale=high-low)
        print(f"1 - CDF at x = {x}: {result}")
    else:
        print("Invalid choice")
		

def normal_lognormal_calculations():
    print("\n" + "="*50)
    print("Normal-Lognormal Calculations".center(50))
    print("="*50)
    print("1. Normal to Lognormal")
    print("2. Lognormal to Normal")
    print("="*50)
    
    choice = input("Enter choice (1-2): ")
    
    if choice == '1':
        normal_to_lognormal()
    elif choice == '2':
        lognormal_to_normal()
    else:
        print("Invalid choice")

def normal_to_lognormal():
    print("\n" + "="*50)
    print("Normal to Lognormal".center(50))
    print("="*50)
    
    mu = float(input("Enter normal distribution mean: "))
    sigma_sq = float(input("Enter normal distribution variance: "))
    
    lognormal_mu = math.exp(mu + sigma_sq / 2)
    lognormal_sigma_sq = (math.exp(sigma_sq) - 1) * math.exp(2 * mu + sigma_sq)
    
    print(f"Lognormal distribution mean: {lognormal_mu}")
    print(f"Lognormal distribution variance: {lognormal_sigma_sq}")

def lognormal_to_normal():
    print("\n" + "="*50)
    print("Lognormal to Normal".center(50))
    print("="*50)
    
    lognormal_mu = float(input("Enter lognormal distribution mean: "))
    lognormal_sigma_sq = float(input("Enter lognormal distribution variance: "))
    
    mu = math.log(lognormal_mu / math.sqrt(1 + lognormal_sigma_sq / (lognormal_mu ** 2)))
    sigma_sq = math.log(1 + lognormal_sigma_sq / (lognormal_mu ** 2))
    
    print(f"Normal distribution mean: {mu}")
    print(f"Normal distribution variance: {sigma_sq}")

def basic_operations():
    try:
        expr = input("Enter expression (e.g., 3+5*2): ")
        result = eval(expr)
        print(f"Result: {result}")
    except Exception as e:
        print(f"Error: {str(e)}")

def trig_functions():
    angle = float(input("Enter angle in degrees: "))
    rad = math.radians(angle)
    if angle % 180 == 90:
        print(f"sin: {math.sin(rad):.6f}")
        print(f"cos: {math.cos(rad):.6f}")
        print(f"tan({angle}°) is undefined")
    else:
        print(f"sin: {math.sin(rad):.6f}")
        print(f"cos: {math.cos(rad):.6f}")
        print(f"tan: {math.tan(rad):.6f}")

def log_exp():
    num = float(input("Enter number: "))
    base = float(input("Enter log base (e for natural log): ").replace('e', str(math.e)))
    if num <= 0 or base <= 0:
        print("Error: Values must be positive")
        return
    print(f"log{base}({num}) = {math.log(num, base):.6f}")

def matrix_operations():
    print("1. Addition\n2. Multiplication\n3. Inverse\n4. Determinant")
    choice = input("> ")
    try:
        if choice in ['1', '2']:
            mat1 = get_matrix("first")
            mat2 = get_matrix("second") if choice == '1' else get_matrix("second (columns must match first's rows)")
        else:
            mat = get_matrix("")

        if choice == '1':
            if len(mat1) != len(mat2) or len(mat1[0]) != len(mat2[0]):
                raise ValueError("Matrices must have same dimensions")
            result = [[a + b for a, b in zip(r1, r2)] for r1, r2 in zip(mat1, mat2)]
        elif choice == '2':
            if len(mat1[0]) != len(mat2):
                raise ValueError("Columns of first must match rows of second")
            result = [[sum(a*b for a, b in zip(r, c)) for c in zip(*mat2)] for r in mat1]
        elif choice == '3':
            sym_mat = sp.Matrix(mat)
            result = sym_mat.inv().tolist()
        elif choice == '4':
            sym_mat = sp.Matrix(mat)
            print(f"Determinant: {sym_mat.det():.6f}")
            return
        else:
            print("Invalid choice")
            return

        print_matrix(result)
    except Exception as e:
        print(f"Error: {str(e)}")

def get_matrix(name):
    rows = int(input(f"Enter {name} matrix rows: "))
    cols = int(input(f"Enter {name} matrix columns: "))
    matrix = []
    for i in range(rows):
        row = list(map(float, input(f"Row {i+1} (space-separated): ").split()))
        if len(row) != cols:
            raise ValueError("Invalid row length")
        matrix.append(row)
    return matrix

def print_matrix(mat):
    print("\nResult Matrix:")
    for row in mat:
        print(" | ".join(f"{num:>8.4f}" for num in row))

def equation_solver():
    print("1. Linear (2-4 vars)\n2. Quadratic\n3. Cubic")
    choice = input("> ")
    try:
        if choice == '1':
            n = int(input("Enter number of variables (2-4): "))
            if n < 2 or n > 4:
                raise ValueError
            solve_linear(n)
        elif choice == '2':
            a, b, c = map(float, input("Enter a b c: ").split())
            solve_quadratic(a, b, c)
        elif choice == '3':
            a, b, c, d = map(float, input("Enter a b c d: ").split())
            solve_cubic(a, b, c, d)
    except Exception as e:
        print(f"Error: {str(e)}")

def solve_linear(n):
    vars = sp.symbols('x y z w')[:n]
    eqs = []
    for i in range(n):
        eq = input(f"Eq {i+1}: ").replace('=', '-')
        eqs.append(sp.parse_expr(eq))
    solution = sp.linsolve(eqs, vars)
    print_solutions(solution)

def solve_quadratic(a, b, c):
    discriminant = b**2 - 4*a*c
    if discriminant > 0:
        x1 = (-b + math.sqrt(discriminant)) / (2*a)
        x2 = (-b - math.sqrt(discriminant)) / (2*a)
        print(f"x1 = {x1:.6f}\nx2 = {x2:.6f}")
    elif discriminant == 0:
        print(f"x = {-b/(2*a):.6f}")
    else:
        real = -b/(2*a)
        imag = math.sqrt(-discriminant)/(2*a)
        print(f"x = {real:.6f} ± {imag:.6f}i")

def solve_cubic(a, b, c, d):
    x = sp.symbols('x')
    solutions = sp.solve(a*x**3 + b*x**2 + c*x + d, x)
    
    # Print solutions, including imaginary roots
    for i, solution in enumerate(solutions):
        if solution.is_real:
            print(f"x{i+1} = {solution}")
        else:
            print(f"x{i+1} = {solution.as_real_imag()[0]} + {solution.as_real_imag()[1]}i")

def print_solutions(solutions):
    if not solutions:
        print("No solution")
        return
    for i, sol in enumerate(solutions):
        print(f"Solution {i+1}: {sol.evalf():.6f}")

def integral_calculator():
    f = input("Enter function (in terms of x): ")
    a = float(input("Lower limit: "))
    b = float(input("Upper limit: "))
    x = sp.symbols('x')
    integral = sp.integrate(sp.parse_expr(f), (x, a, b))
    print(f"Definite integral: {integral.evalf():.6f}")

def number_inverse():
    num = float(input("Enter number: "))
    if num == 0:
        print("Error: Division by zero")
    else:
        print(f"1/{num} = {1/num:.10f}")

def decimal_to_fraction():
    num = input("Enter decimal: ")
    try:
        f = Fraction(num).limit_denominator()
        
        # Check if numerator is greater than denominator
        if f.numerator > f.denominator:
            whole_number = f.numerator // f.denominator
            remainder = f.numerator % f.denominator
            
            # Print mixed fraction
            print(f"{num} = {whole_number} {remainder}/{f.denominator}")
            print()
            print(f"{num} = {f.numerator}/{f.denominator}")
        else:
            print(f"{num} = {f.numerator}/{f.denominator}")
    except:
        print("Invalid decimal")

def inverse_trig():
    print("1. arcsin\n2. arccos\n3. arctan")
    choice = input("> ")
    val = float(input("Enter value: "))
    try:
        if choice == '1':
            if abs(val) > 1:
                raise ValueError("Value must be between -1 and 1")
            res = math.degrees(math.asin(val))
        elif choice == '2':
            if abs(val) > 1:
                raise ValueError("Value must be between -1 and 1")
            res = math.degrees(math.acos(val))
        elif choice == '3':
            res = math.degrees(math.atan(val))
        else:
            print("Invalid choice")
            return
        print(f"Result: {res:.6f} degrees")
    except Exception as e:
        print(f"Error: {str(e)}")

def square_and_square_root():
    num = float(input("Enter number: "))
    print(f"Square: {num ** 2}")
    print(f"Square Root: {math.sqrt(num)}")

def power_and_nth_root():
    base = float(input("Enter base number: "))
    exp = float(input("Enter exponent (for nth root, enter 1/n): "))
    print(f"Power: {base ** exp}")
    if exp == 1/2:
        print(f"Square Root: {math.sqrt(base)}")
    elif exp == 1/3:
        print(f"Cube Root: {base ** (1/3)}")
    else:
        print(f"Nth Root: {base ** (1/exp)}")

def calculate_max_min():
    f = input("Enter function (in terms of x): ")
    x = sp.symbols('x')
    func = sp.parse_expr(f)
    
    # Calculate derivative
    derivative = sp.diff(func, x)
    
    # Solve for critical points
    critical_points = sp.solve(derivative, x)
    
    # Print critical points
    print("Critical points:")
    for point in critical_points:
        print(f"x = {point}")
        
    # Calculate second derivative
    second_derivative = sp.diff(derivative, x)
    
    # Determine maxima/minima
    print("\nMaxima/Minima:")
    for point in critical_points:
        if second_derivative.subs(x, point) > 0:
            print(f"Minimum at x = {point}")
        elif second_derivative.subs(x, point) < 0:
            print(f"Maximum at x = {point}")
        else:
            print(f"Inflection point at x = {point}")

def combinations_permutations():
    print("\n" + "="*50)
    print("Combinations, Permutations, and Factorial".center(50))
    print("="*50)
    print("1. nCr (Combinations)")
    print("2. nPr (Permutations)")
    print("3. Factorial (n!)")
    print("="*50)
    
    choice = input("Enter choice (1-3): ")
    
    if choice == '1':
        n = int(input("Enter total number of items (n): "))
        r = int(input("Enter number of items to choose (r): "))
        result = math.comb(n, r)
        print(f"{n}C{r} = {result}")
    elif choice == '2':
        n = int(input("Enter total number of items (n): "))
        r = int(input("Enter number of items to choose (r): "))
        result = math.perm(n, r)
        print(f"{n}P{r} = {result}")
    elif choice == '3':
        n = int(input("Enter number for factorial calculation (n): "))
        result = math.factorial(n)
        print(f"{n}! = {result}")
    else:
        print("Invalid choice")

def main():
    while True:
        display_menu()
        choice = input("Enter choice (1-16): ")
        if choice == '16':
            print("Exiting calculator...")
            break
        try:
            {
                '1': basic_operations,
                '2': trig_functions,
                '3': log_exp,
                '4': matrix_operations,
                '5': equation_solver,
                '6': integral_calculator,
                '7': number_inverse,
                '8': decimal_to_fraction,
                '9': inverse_trig,
                '10': square_and_square_root,
                '11': power_and_nth_root,
                '12': calculate_max_min,
                '13': stats_functions,
                '14': normal_lognormal_calculations,
                '15': combinations_permutations
            }.get(choice, lambda: print("Invalid choice"))()

            # Add 5 blank lines after each operation output
            print("\n" * 5)

        except Exception as e:
            print(f"Unexpected error: {str(e)}")
            print("\n" * 5)  # Maintain spacing even for errors

if __name__ == "__main__":
    main()
