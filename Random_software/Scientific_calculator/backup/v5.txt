import math
import sympy as sp
import ipywidgets as widgets
from IPython.display import display

# --- Global State ---
calc_state = {
    "expression": "",
    "currentFunction": "",
    "result": "",
    "equation_mode": False
}

# --- Display Widgets ---
display_style = "text-align:right; font-size:32px; color:white; background:#1a1a1a; padding:10px; border-radius:8px; min-height:45px;"

expression_display = widgets.HTML(value=f"<div style='{display_style}'>{calc_state['expression']}</div>")
result_display = widgets.HTML(value=f"<div style='{display_style}'>{calc_state['result']}</div>")

# --- Equation Solver UI Elements ---
equation_dropdown = widgets.Dropdown(
    options=[("Select", ""), ("2 Variables (x, y)", 2), ("3 Variables (x, y, z)", 3)],
    description="Equation Solver:",
    style={'description_width': 'initial'}
)

equation_container = widgets.VBox([])  # Holds input fields for coefficients
solve_button = widgets.Button(description="Solve", button_style="primary")
equation_result_display = widgets.HTML(value="")  # Solution display

def update_display():
    expr = f"{calc_state['currentFunction']}({calc_state['expression']})" if calc_state["currentFunction"] else calc_state["expression"]
    expression_display.value = f"<div style='{display_style}'>{expr if expr else '&nbsp;'}</div>"
    result_display.value = f"<div style='{display_style}'>{calc_state['result'] if calc_state['result'] else '&nbsp;'}</div>"

# --- Calculator Functions ---
def append_to_expr(val):
    calc_state["expression"] += val
    update_display()

def clear_calc(b=None):
    calc_state["expression"] = ""
    calc_state["currentFunction"] = ""
    calc_state["result"] = ""
    calc_state["equation_mode"] = False
    update_display()
    equation_dropdown.value = ""  # Reset dropdown
    equation_container.children = []  # Clear input table
    equation_result_display.value = ""  # Clear results

def backspace(b=None):
    calc_state["expression"] = calc_state["expression"][:-1]
    update_display()

def set_function(func):
    calc_state["currentFunction"] = func
    calc_state["expression"] = ""
    calc_state["result"] = ""
    update_display()

def calculate(b=None):
    try:
        full_expr = f"{calc_state['currentFunction']}({calc_state['expression']})" if calc_state["currentFunction"] else calc_state["expression"]
        
        if calc_state["currentFunction"]:
            value = float(calc_state["expression"]) if calc_state["expression"] else 0
            func = calc_state["currentFunction"]
            if func == "sin":
                calc_state["result"] = str(math.sin(math.radians(value)))
            elif func == "log":
                calc_state["result"] = str(math.log10(value)) if value > 0 else "Error"
            calc_state["currentFunction"] = ""  # Reset function mode
        else:
            calc_state["result"] = str(eval(calc_state["expression"]))

        calc_state["expression"] = full_expr
        update_display()
    except Exception:
        calc_state["result"] = "Error"
        update_display()

# --- Equation Solver ---
def generate_equation_inputs(change):
    """Generates input fields for the selected number of variables."""
    num_vars = change['new']
    if not num_vars:
        equation_container.children = []
        return
    
    headers = ["x", "y", "z"][:num_vars] + ["="]
    input_grid = []

    for row in range(num_vars):
        row_inputs = []
        for col in range(num_vars + 1):  # Extra column for constant
            inp = widgets.FloatText(value=0, layout=widgets.Layout(width='60px'))
            row_inputs.append(inp)
        input_grid.append(row_inputs)

    # Convert to UI elements
    grid_ui = [widgets.HBox([widgets.Label(value=h, layout=widgets.Layout(width='40px')) for h in headers])]  # Column headers
    for row in input_grid:
        grid_ui.append(widgets.HBox(row))
    
    equation_container.children = grid_ui
    solve_button.on_click(lambda b: solve_equations(num_vars, input_grid))

def solve_equations(num_vars, input_grid):
    """Solves the system of equations given the input table."""
    try:
        symbols = sp.symbols('x y z')[:num_vars]  # Select relevant variables
        equations = []

        for row in input_grid:
            lhs = sum(coeff.value * var for coeff, var in zip(row[:-1], symbols))
            rhs = row[-1].value
            equations.append(sp.Eq(lhs, rhs))

        solution = sp.solve(equations, symbols)
        if solution:
            solution_text = ", ".join(f"{k} = {v}" for k, v in solution.items())
        else:
            solution_text = "No solution or infinite solutions"

        equation_result_display.value = f"<div style='{display_style}'>{solution_text}</div>"
    except Exception as e:
        equation_result_display.value = f"<div style='{display_style}'>Error: Invalid input</div>"

# --- Create Buttons ---
btn_clear = widgets.Button(description="C", button_style="warning")
btn_back = widgets.Button(description="âŒ«", button_style="warning")

btn_sin = widgets.Button(description="sin", button_style="info")
btn_log = widgets.Button(description="log", button_style="info")

btn_clear.on_click(clear_calc)
btn_back.on_click(backspace)
btn_sin.on_click(lambda b: set_function("sin"))
btn_log.on_click(lambda b: set_function("log"))

# **NEW TOP ROW**: Clear button + Equation Solver dropdown
top_row = widgets.HBox([btn_clear, equation_dropdown])

# **SECOND ROW**: Backspace, sin, log
second_row = widgets.HBox([btn_back, btn_sin, btn_log])

# Bottom grid: numbers and basic operators
button_descriptions = [
    "7", "8", "9", "/",
    "4", "5", "6", "*",
    "1", "2", "3", "-",
    "0", ".", "=", "+"
]

num_buttons = []
for desc in button_descriptions:
    btn = widgets.Button(description=desc)
    if desc == "=":
        btn.on_click(calculate)
    elif desc in ["/", "*", "-", "+"]:
        btn.on_click(lambda b, d=desc: append_to_expr(d))
    else:
        btn.on_click(lambda b, d=desc: append_to_expr(d))
    num_buttons.append(btn)

grid = widgets.GridBox(num_buttons,
                         layout=widgets.Layout(
                             grid_template_columns="repeat(4, 1fr)",
                             grid_gap="5px"
                         ))

# Attach dropdown event
equation_dropdown.observe(generate_equation_inputs, names="value")

# --- Assemble UI ---
equation_solver_ui = widgets.VBox([equation_container, solve_button, equation_result_display])
calc_ui = widgets.VBox([expression_display, result_display, top_row, second_row, grid, equation_solver_ui])

update_display()
display(calc_ui)