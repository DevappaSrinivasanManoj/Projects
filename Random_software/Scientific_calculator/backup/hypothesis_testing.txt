# @title Default title text
import re
import numpy as np
import pandas as pd
from scipy.stats import norm
import ipywidgets as widgets
from IPython.display import display, clear_output

# For proportions tests, we use statsmodels:
try:
    from statsmodels.stats.proportion import proportions_ztest
except ImportError:
    raise ImportError("Please install statsmodels to run proportions tests (pip install statsmodels)")

# -------------------------------------------------
# Helper Calculation Functions (using built-in libraries)
# -------------------------------------------------

def calc_one_sample_means(data, pop_mean, pop_std):
    n = len(data)
    sample_mean = np.mean(data)
    z = (sample_mean - pop_mean) / (pop_std/np.sqrt(n))
    p_value = 2 * (1 - norm.cdf(abs(z)))
    return z, p_value

def calc_two_sample_means(data1, data2):
    n1, n2 = len(data1), len(data2)
    mean1, mean2 = np.mean(data1), np.mean(data2)
    std1, std2 = np.std(data1, ddof=1), np.std(data2, ddof=1)
    se = np.sqrt(std1**2/n1 + std2**2/n2)
    z = (mean1 - mean2) / se
    p_value = 2 * (1 - norm.cdf(abs(z)))
    return z, p_value

def calc_one_sample_prop(data, pop_prop):
    n = len(data)
    count = np.sum(data)  # assumes binary (0/1)
    # Using statsmodels for proportions
    z, p_value = proportions_ztest(count, n, value=pop_prop, alternative='two-sided')
    return z, p_value

def calc_two_sample_prop(data1, data2):
    n1, n2 = len(data1), len(data2)
    count1, count2 = np.sum(data1), np.sum(data2)
    z, p_value = proportions_ztest([count1, count2], [n1, n2], alternative='two-sided')
    return z, p_value

# -------------------------------------------------
# UI Builder Functions for Each Test
# -------------------------------------------------

def build_one_sample_z_means_ui():
    """Build UI for One Sample z-test (Means) with options for tail type, direction, and significance level."""
    
    # Dropdown for Input Mode
    mode_dd = widgets.Dropdown(options=["Data List", "Summary Statistics"], 
                               value="Data List", description="Input Mode:")
    
    # Dropdown for Tail Type
    tail_dd = widgets.Dropdown(options=["Two Tailed", "One Tailed"],
                               value="Two Tailed", description="Tail Type:",
                               style={'description_width': '150px'})

    # Dropdown for Direction (hidden by default)
    direction_dd = widgets.Dropdown(options=["Greater Than", "Less Than"],
                                    value="Greater Than", description="Direction:",
                                    style={'description_width': '150px'})

    # Direction container with dynamic visibility
    direction_box = widgets.HBox([direction_dd], layout=widgets.Layout(visibility='hidden'))

    # Data Source Selection
    data_source = widgets.RadioButtons(options=["Upload CSV/Excel", "Manual Entry"],
                                       value="Upload CSV/Excel", description="Data Source:")
    
    # File Upload and Column Selector
    file_upload = widgets.FileUpload(accept='.csv, .xlsx', multiple=False, description="Upload File")
    column_selector = widgets.Dropdown(options=[], description="Select Column:", 
                                       style={'description_width': '150px'})
    
    # Manual Entry Widget
    manual_text = widgets.Textarea(value="", placeholder="Enter numbers (comma separated)",
                                   description="Data List:", layout=widgets.Layout(width='50%', height='80px'))
    
    # Population Parameters
    pop_mean_in = widgets.FloatText(value=0.0, description="Population Mean:", 
                                    style={'description_width': '150px'})
    pop_std_in = widgets.FloatText(value=1.0, description="Population Std Dev:", 
                                   style={'description_width': '150px'})
    
    # Significance Level
    sig_level_in = widgets.FloatText(value=0.05, description="Significance Level:", 
                                     style={'description_width': '150px'})
    
    output_area = widgets.Output()
    run_button = widgets.Button(description="Run Test", button_style='success')
    
    # Container for Data List mode
    data_list_box = widgets.VBox()

    def update_data_source(change):
        """Toggle between Upload and Manual Entry."""
        if data_source.value == "Upload CSV/Excel":
            data_list_box.children = [file_upload, column_selector,
                                      widgets.HTML("<b>Population Parameters:</b>"),
                                      pop_mean_in, pop_std_in]
        else:
            data_list_box.children = [manual_text,
                                      widgets.HTML("<b>Population Parameters:</b>"),
                                      pop_mean_in, pop_std_in]
    
    data_source.observe(update_data_source, names='value')
    update_data_source(None)
    
    # Container for Summary Statistics mode
    sample_mean_in = widgets.FloatText(value=0.0, description="Sample Mean:", 
                                       style={'description_width': '150px'})
    sample_size_in = widgets.IntText(value=30, description="Sample Size:")
    
    summary_box = widgets.VBox([widgets.HTML("<b>Enter Summary Statistics:</b>"),
                                pop_mean_in, pop_std_in, sample_mean_in, sample_size_in])
    
    container = widgets.VBox([mode_dd, tail_dd, direction_box, output_area])
    
    def update_mode(change):
        """Switch between Data List and Summary Statistics mode."""
        if mode_dd.value == "Data List":
            container.children = (mode_dd, tail_dd, direction_box, data_source, data_list_box, sig_level_in, run_button, output_area)
        else:
            container.children = (mode_dd, tail_dd, direction_box, summary_box, sig_level_in, run_button, output_area)
    
    mode_dd.observe(update_mode, names='value')
    update_mode(None)
    
    # Show/Hide direction dropdown based on tail type
    def update_tail_type(change):
        """Toggle visibility of direction dropdown."""
        if tail_dd.value == "One Tailed":
            direction_box.layout.visibility = 'visible'
        else:
            direction_box.layout.visibility = 'hidden'
    
    tail_dd.observe(update_tail_type, names='value')
    update_tail_type(None)
    
    # Update column selector when a file is uploaded
    def update_column_selector(change):
        if file_upload.value:
            uploaded_file = list(file_upload.value.values())[0]
            try:
                df = pd.read_csv(pd.io.common.BytesIO(uploaded_file['content']))
            except Exception:
                try:
                    df = pd.read_excel(pd.io.common.BytesIO(uploaded_file['content']))
                except Exception as e:
                    with output_area:
                        clear_output()
                        print("Error reading file:", e)
                    return
            column_selector.options = list(df.columns)
    
    file_upload.observe(update_column_selector, 'value')
    
    # Run test action
    def run_test_action(b):
        with output_area:
            clear_output()
            try:
                alpha = float(sig_level_in.value)
            except Exception as e:
                print("Invalid significance level:", e)
                return
            
            # Data List mode
            if mode_dd.value == "Data List":
                if data_source.value == "Upload CSV/Excel":
                    if file_upload.value:
                        uploaded_file = list(file_upload.value.values())[0]
                        try:
                            try:
                                df = pd.read_csv(pd.io.common.BytesIO(uploaded_file['content']))
                            except:
                                df = pd.read_excel(pd.io.common.BytesIO(uploaded_file['content']))
                        except Exception as e:
                            print("Error reading file:", e)
                            return
                        col = column_selector.value
                        try:
                            data = pd.to_numeric(df[col], errors='coerce').dropna().tolist()
                        except Exception as e:
                            print("Error processing data:", e)
                            return
                    else:
                        print("Please upload a file.")
                        return
                    pop_mean = pop_mean_in.value
                    pop_std = pop_std_in.value
                    z, p_val = calc_one_sample_means(data, pop_mean, pop_std)
                    sample_mean_val = np.mean(data)
                else:
                    try:
                        data = [float(x.strip()) for x in manual_text.value.split(",") if x.strip() != ""]
                    except Exception as e:
                        print("Error processing manual data:", e)
                        return
                    pop_mean = pop_mean_in.value
                    pop_std = pop_std_in.value
                    z, p_val = calc_one_sample_means(data, pop_mean, pop_std)
                    sample_mean_val = np.mean(data)
            
            # Summary Statistics mode
            else:
                pop_mean = pop_mean_in.value
                pop_std = pop_std_in.value
                sample_mean_val = sample_mean_in.value
                n = sample_size_in.value
                z = (sample_mean_val - pop_mean) / (pop_std / np.sqrt(n))
                p_val = 2 * (1 - norm.cdf(abs(z)))
            
            # Adjust p-value based on tail type and direction
            if tail_dd.value == "One Tailed":
                direction = direction_dd.value
                if direction == "Greater Than":
                    p = 1 - norm.cdf(z)
                    if p < alpha:
                        result_message = (f"The sample mean ({sample_mean_val}) is statistically greater than the population mean ({pop_mean}).")
                    else:
                        result_message = (f"The sample mean ({sample_mean_val}) is NOT statistically greater than the population mean ({pop_mean}); "
                                          f"there is insufficient evidence to conclude it is greater.")
                else:
                    p = norm.cdf(z)
                    if p < alpha:
                        result_message = (f"The sample mean ({sample_mean_val}) is statistically less than the population mean ({pop_mean}).")
                    else:
                        result_message = (f"The sample mean ({sample_mean_val}) is NOT statistically less than the population mean ({pop_mean}); "
                                          f"there is insufficient evidence to conclude it is less.")
            else:
                # Two-tailed test
                p = p_val
                if p < alpha:
                    result_message = (f"There is a statistically significant difference between the sample mean ({sample_mean_val}) "
                                      f"and the population mean ({pop_mean}).")
                else:
                    result_message = (f"There is NO statistically significant difference between the sample mean ({sample_mean_val}) "
                                      f"and the population mean ({pop_mean}).")

            # Print results
            print("One Sample z-test (Means):")
            print("z statistic:", z)
            print("p-value:", p)
            print(result_message)
            print(f"At a significance level of {alpha}, we {'reject' if p < alpha else 'fail to reject'} the null hypothesis.")
    
    run_button.on_click(run_test_action)
    
    return container


def build_two_sample_z_means_ui():
    """Build UI for Two Sample z-test (Means) with a Data Source option, tail type, and significance level."""
    mode_dd = widgets.Dropdown(options=["Data List", "Summary Statistics"], value="Data List", description="Input Mode:")
    # Tail type selection:
    tail_dd = widgets.Dropdown(options=["Two Tailed", "One Tailed"],
                               value="Two Tailed", description="Tail Type:",
                               style={'description_width': '150px'})
    # For one-tailed tests, add a direction dropdown:
    direction_dd = widgets.Dropdown(options=[("Sample1 > Sample2", "gt"), ("Sample1 < Sample2", "lt")],
                                    value="gt", description="Direction:",
                                    style={'description_width': '150px'})
    direction_dd.layout.display = 'none'  # Hidden by default; shown if One Tailed is selected.
    
    # Data Source Radio Button:
    data_source = widgets.RadioButtons(options=["Upload CSV/Excel", "Manual Entry"],
                                        value="Upload CSV/Excel", description="Data Source:")
    # Data List mode widgets:
    file_upload = widgets.FileUpload(accept='.csv, .xlsx', multiple=False, description="Upload File")
    col_sel1 = widgets.Dropdown(options=[], description="Column S1:")
    col_sel2 = widgets.Dropdown(options=[], description="Column S2:")
    manual_text = widgets.Textarea(value="", placeholder="Enter two lists (e.g., [1,2,3], [4,5,6])", 
                                   description="Data Lists:", layout=widgets.Layout(width='70%', height='100px'))
    # Summary Statistics mode widgets:
    s1_mean = widgets.FloatText(value=0.0, description="Sample 1 Mean:", style={'description_width': '150px'})
    s1_std = widgets.FloatText(value=1.0, description="Sample 1 Std Dev:", style={'description_width': '150px'})
    s1_size = widgets.IntText(value=30, description="Sample 1 Size:", style={'description_width': '150px'})
    s2_mean = widgets.FloatText(value=0.0, description="Sample 2 Mean:", style={'description_width': '150px'})
    s2_std = widgets.FloatText(value=1.0, description="Sample 2 Std Dev:", style={'description_width': '150px'})
    s2_size = widgets.IntText(value=30, description="Sample 2 Size:", style={'description_width': '150px'})
    
    # Significance Level widget for Two Sample test
    sig_level_in = widgets.FloatText(value=0.05, description="Significance Level:",
                                     style={'description_width': '150px'})
    
    output_area = widgets.Output()
    run_button = widgets.Button(description="Run Test", button_style='success')
    
    # Container for Data List mode
    data_list_box = widgets.VBox()
    def update_data_source(change):
        if data_source.value == "Upload CSV/Excel":
            data_list_box.children = [file_upload, widgets.HBox([col_sel1, col_sel2])]
        else:
            data_list_box.children = [manual_text]
    data_source.observe(update_data_source, names='value')
    update_data_source(None)
    
    # Container for Summary Statistics mode
    summary_box = widgets.VBox([s1_mean, s1_std, s1_size, s2_mean, s2_std, s2_size])
    
    # Main container: include mode, tail type, direction (if needed), significance level, then the appropriate input container.
    container = widgets.VBox([mode_dd, tail_dd, output_area])
    def update_mode(change):
        if tail_dd.value == "One Tailed":
            direction_dd.layout.display = 'block'
        else:
            direction_dd.layout.display = 'none'
        if mode_dd.value == "Data List":
            container.children = (mode_dd, tail_dd, direction_dd, data_source, data_list_box, sig_level_in, run_button, output_area)
        else:
            container.children = (mode_dd, tail_dd, direction_dd, summary_box, sig_level_in, run_button, output_area)
    mode_dd.observe(update_mode, names='value')
    tail_dd.observe(update_mode, names='value')
    update_mode(None)
    
    def update_col_selectors(change):
        if file_upload.value:
            uploaded_file = list(file_upload.value.values())[0]
            try:
                df = pd.read_csv(pd.io.common.BytesIO(uploaded_file['content']))
            except Exception:
                try:
                    df = pd.read_excel(pd.io.common.BytesIO(uploaded_file['content']))
                except Exception as e:
                    with output_area:
                        clear_output()
                        print("Error reading file:", e)
                    return
            options = list(df.columns)
            col_sel1.options = options
            col_sel2.options = options
    file_upload.observe(update_col_selectors, 'value')
    
    def run_test_action(b):
        with output_area:
            clear_output()
            try:
                alpha = float(sig_level_in.value)
            except Exception as e:
                print("Invalid significance level:", e)
                return
            
            # Data List mode:
            if mode_dd.value == "Data List":
                if data_source.value == "Upload CSV/Excel":
                    if file_upload.value:
                        uploaded_file = list(file_upload.value.values())[0]
                        try:
                            try:
                                df = pd.read_csv(pd.io.common.BytesIO(uploaded_file['content']))
                            except:
                                df = pd.read_excel(pd.io.common.BytesIO(uploaded_file['content']))
                        except Exception as e:
                            print("Error reading file:", e)
                            return
                        col1 = col_sel1.value
                        col2 = col_sel2.value
                        try:
                            data1 = pd.to_numeric(df[col1], errors='coerce').dropna().tolist()
                            data2 = pd.to_numeric(df[col2], errors='coerce').dropna().tolist()
                        except Exception as e:
                            print("Error processing data:", e)
                            return
                    else:
                        print("Please upload a file.")
                        return
                    z, p_val = calc_two_sample_means(data1, data2)
                else:
                    try:
                        lists_found = re.findall(r'\[([^\]]+)\]', manual_text.value)
                        if len(lists_found) != 2:
                            print("Enter exactly two lists separated by a comma.")
                            return
                        data1 = [float(x.strip()) for x in lists_found[0].split(",") if x.strip() != ""]
                        data2 = [float(x.strip()) for x in lists_found[1].split(",") if x.strip() != ""]
                    except Exception as e:
                        print("Error processing manual data:", e)
                        return
                    z, p_val = calc_two_sample_means(data1, data2)
            else:
                z = (s1_mean.value - s2_mean.value) / np.sqrt(s1_std.value**2/s1_size.value + s2_std.value**2/s2_size.value)
                p_val = 2 * (1 - norm.cdf(abs(z)))
            
            # Adjust p-value and message based on tail type:
            if tail_dd.value == "One Tailed":
                direction_choice = direction_dd.value  # "gt" or "lt"
                if direction_choice == "gt":
                    p = 1 - norm.cdf(z)
                    outcome = "Sample 1 is statistically greater than Sample 2." if z > 0 else "No evidence that Sample 1 is greater than Sample 2."
                else:  # "lt"
                    p = norm.cdf(z)
                    outcome = "Sample 1 is statistically less than Sample 2." if z < 0 else "No evidence that Sample 1 is less than Sample 2."
            else:
                p = p_val
                if p < alpha:
                    outcome = "There is a statistically significant difference between the two samples."
                else:
                    outcome = "There is no statistically significant difference between the two samples."
            
            decision = "reject" if p < alpha else "fail to reject"
            print("Two Sample z-test (Means):")
            print("z statistic:", z)
            print("p-value:", p)
            print(outcome)
            print(f"At a significance level of {alpha}, we {decision} the null hypothesis.")
    run_button.on_click(run_test_action)
    
    return container


def build_one_sample_z_proportions_ui():
    """Build UI for One Sample z-proportions test with options for tail type, significance level,
       arranged in separate rows so that no widgets overlap.
    """
    import re
    import numpy as np
    import pandas as pd
    from scipy.stats import norm
    # Assume calc_one_sample_prop is defined elsewhere; if not, you can use the following:
    def calc_one_sample_prop(data, pop_prop):
        n = len(data)
        z = (np.mean(data) - pop_prop) / np.sqrt(pop_prop * (1 - pop_prop) / n)
        p = 2 * (1 - norm.cdf(abs(z)))
        return z, p

    # Population proportion input (needed for both modes)
    pop_prop_in = widgets.FloatText(value=0.5, description="Population Proportion:",
                                    style={'description_width': '150px'})
    
    # Mode selection: Data List vs. Summary Statistics
    mode_dd = widgets.Dropdown(options=["Data List", "Summary Statistics"],
                                value="Data List", description="Input Mode:",
                                style={'description_width': '150px'})
    
    # Tail type selection (each on its own row)
    tail_dd = widgets.Dropdown(options=["Two Tailed", "One Tailed"],
                               value="Two Tailed", description="Tail Type:",
                               style={'description_width': '150px'})
    
    # Direction dropdown for one-tailed tests (on a separate row; initially hidden)
    direction_dd = widgets.Dropdown(options=[("Sample proportion > Population proportion", "gt"),
                                              ("Sample proportion < Population proportion", "lt")],
                                    value="gt", description="Direction:",
                                    style={'description_width': '150px'},
                                    layout=widgets.Layout(width='100%'))
    direction_dd.layout.display = 'none'
    
    # Data Source selection (for Data List mode)
    data_source = widgets.RadioButtons(options=["Upload CSV/Excel", "Manual Entry"],
                                       value="Upload CSV/Excel", description="Data Source:",
                                       style={'description_width': '150px'})
    
    # Widgets for Data List mode:
    file_upload = widgets.FileUpload(accept='.csv, .xlsx', multiple=False, description="Upload File")
    column_selector = widgets.Dropdown(options=[], description="Select Column:",
                                       style={'description_width': '150px'})
    manual_text = widgets.Textarea(value="", placeholder="Enter binary data (0/1) separated by commas",
                                   description="Data List:", 
                                   layout=widgets.Layout(width='50%', height='80px'))
    
    # Container for Data List mode (updates based on data_source)
    data_list_box = widgets.VBox([], layout=widgets.Layout(width='100%'))
    def update_data_source(change):
        if data_source.value == "Upload CSV/Excel":
            data_list_box.children = [file_upload, column_selector]
        else:
            data_list_box.children = [manual_text]
    data_source.observe(update_data_source, names='value')
    update_data_source(None)
    
    # Summary Statistics mode widgets:
    sample_prop_in = widgets.FloatText(value=0.0, description="Sample Proportion:",
                                       style={'description_width': '150px'})
    sample_size_in = widgets.IntText(value=30, description="Sample Size:",
                                     style={'description_width': '150px'})
    summary_box = widgets.VBox([widgets.HTML("<b>Summary Statistics for Proportions:</b>"),
                                pop_prop_in, sample_prop_in, sample_size_in],
                               layout=widgets.Layout(width='100%'))
    
    # Significance Level widget:
    sig_level_in = widgets.FloatText(value=0.05, description="Significance Level:",
                                     style={'description_width': '150px'})
    
    output_area = widgets.Output(layout=widgets.Layout(width='100%'))
    run_button = widgets.Button(description="Run Test", button_style='success')
    
    # Build main container using a helper function to create a VBox with each widget as a row.
    def update_main_container():
        rows = []
        rows.append(mode_dd)
        rows.append(tail_dd)
        if tail_dd.value == "One Tailed":
            rows.append(direction_dd)
        if mode_dd.value == "Data List":
            rows.append(data_source)
            rows.append(data_list_box)
        else:
            rows.append(summary_box)
        rows.append(sig_level_in)
        rows.append(run_button)
        rows.append(output_area)
        return widgets.VBox(rows)
    
    container = update_main_container()
    
    # Update layout when mode or tail type changes.
    def update_layout(change):
        if tail_dd.value == "One Tailed":
            direction_dd.layout.display = 'block'
        else:
            direction_dd.layout.display = 'none'
        new_container = update_main_container()
        container.children = new_container.children
    mode_dd.observe(update_layout, names='value')
    tail_dd.observe(update_layout, names='value')
    update_layout(None)
    
    def update_column_selector(change):
        if file_upload.value:
            uploaded_file = list(file_upload.value.values())[0]
            try:
                df = pd.read_csv(pd.io.common.BytesIO(uploaded_file['content']))
            except Exception:
                try:
                    df = pd.read_excel(pd.io.common.BytesIO(uploaded_file['content']))
                except Exception as e:
                    with output_area:
                        clear_output()
                        print("Error reading file:", e)
                    return
            column_selector.options = list(df.columns)
    file_upload.observe(update_column_selector, 'value')
    
    def run_test_action(b):
        with output_area:
            clear_output()
            try:
                alpha = float(sig_level_in.value)
            except Exception as e:
                print("Invalid significance level:", e)
                return
            
            # Data List mode:
            if mode_dd.value == "Data List":
                if data_source.value == "Upload CSV/Excel":
                    if file_upload.value:
                        uploaded_file = list(file_upload.value.values())[0]
                        try:
                            try:
                                df = pd.read_csv(pd.io.common.BytesIO(uploaded_file['content']))
                            except:
                                df = pd.read_excel(pd.io.common.BytesIO(uploaded_file['content']))
                        except Exception as e:
                            print("Error reading file:", e)
                            return
                        col = column_selector.value
                        try:
                            data = pd.to_numeric(df[col], errors='coerce').dropna().tolist()
                        except Exception as e:
                            print("Error processing data:", e)
                            return
                    else:
                        print("Please upload a file.")
                        return
                    pop_prop = pop_prop_in.value
                    z, computed_p = calc_one_sample_prop(data, pop_prop)
                    sample_prop_val = np.mean(data)
                else:
                    try:
                        data = [float(x.strip()) for x in manual_text.value.split(",") if x.strip() != ""]
                    except Exception as e:
                        print("Error processing manual data:", e)
                        return
                    pop_prop = pop_prop_in.value
                    z, computed_p = calc_one_sample_prop(data, pop_prop)
                    sample_prop_val = np.mean(data)
            else:
                pop_prop = pop_prop_in.value
                sample_prop_val = sample_prop_in.value
                n = sample_size_in.value
                se = np.sqrt(pop_prop * (1 - pop_prop) / n)
                z = (sample_prop_val - pop_prop) / se
                computed_p = 2 * (1 - norm.cdf(abs(z)))
            
            # Adjust p-value and outcome message based on tail type:
            if tail_dd.value == "One Tailed":
                if direction_dd.value == "gt":
                    p = 1 - norm.cdf(z)
                    outcome = ("The sample proportion is statistically greater than the population proportion."
                               if z > 0 else "There is insufficient evidence that the sample proportion is greater than the population proportion.")
                else:
                    p = norm.cdf(z)
                    outcome = ("The sample proportion is statistically less than the population proportion."
                               if z < 0 else "There is insufficient evidence that the sample proportion is less than the population proportion.")
            else:
                p = computed_p
                if p < alpha:
                    outcome = "There is a statistically significant difference between the sample and the population proportion."
                else:
                    outcome = "There is no statistically significant difference between the sample and the population proportion."
            
            decision = "reject" if p < alpha else "fail to reject"
            print("One Sample z-proportions test:")
            print("z statistic:", z)
            print("p-value:", p)
            print(outcome)
            print(f"At a significance level of {alpha}, we {decision} the null hypothesis.")
    run_button.on_click(run_test_action)
    
    return container


def build_two_sample_z_proportions_ui():
    """Build UI for Two Sample z-proportions test with options for tail type, significance level, and Data Source.
       This code is based on your original version with additions.
    """
    import re
    import numpy as np
    import pandas as pd
    from scipy.stats import norm
    from statsmodels.stats.proportion import proportions_ztest

    # Mode selection: Data List vs. Summary Statistics
    mode_dd = widgets.Dropdown(options=["Data List", "Summary Statistics"],
                                value="Data List", description="Input Mode:",
                                style={'description_width': '150px'})
    
    # Tail type selection
    tail_dd = widgets.Dropdown(options=["Two Tailed", "One Tailed"],
                               value="Two Tailed", description="Tail Type:",
                               style={'description_width': '150px'})
    
    # Direction dropdown for one-tailed tests; initially hidden.
    direction_dd = widgets.Dropdown(options=[("Sample1 > Sample2", "gt"),
                                              ("Sample1 < Sample2", "lt")],
                                    value="gt", description="Direction:",
                                    style={'description_width': '150px'})
    direction_dd.layout.display = 'none'
    
    # Significance Level widget
    sig_level_in = widgets.FloatText(value=0.05, description="Significance Level:",
                                     style={'description_width': '150px'})
    
    # Data Source selection for Data List mode
    data_source = widgets.RadioButtons(options=["Upload CSV/Excel", "Manual Entry"],
                                        value="Upload CSV/Excel", description="Data Source:",
                                        style={'description_width': '150px'})
    
    # Widgets for Data List mode:
    file_upload = widgets.FileUpload(accept='.csv, .xlsx', multiple=False, description="Upload File")
    col_sel1 = widgets.Dropdown(options=[], description="Column S1:",
                                style={'description_width': '150px'})
    col_sel2 = widgets.Dropdown(options=[], description="Column S2:",
                                style={'description_width': '150px'})
    manual_text = widgets.Textarea(value="", placeholder="Enter two lists of binary data (0/1), e.g.: [1,0,1], [0,1,1]",
                                   description="Data Lists:", layout=widgets.Layout(width='70%', height='100px'))
    
    # Container for Data List mode; updates based on data_source.
    data_list_box = widgets.VBox()
    def update_data_source(change):
        if data_source.value == "Upload CSV/Excel":
            data_list_box.children = [file_upload, widgets.HBox([col_sel1, col_sel2])]
        else:
            data_list_box.children = [manual_text]
    data_source.observe(update_data_source, names='value')
    update_data_source(None)
    
    # Summary Statistics mode widgets:
    s1_prop = widgets.FloatText(value=0.0, description="Sample 1 Proportion:",
                                style={'description_width': '150px'})
    s1_size = widgets.IntText(value=30, description="Sample 1 Size:",
                               style={'description_width': '150px'})
    s2_prop = widgets.FloatText(value=0.0, description="Sample 2 Proportion:",
                                style={'description_width': '150px'})
    s2_size = widgets.IntText(value=30, description="Sample 2 Size:",
                               style={'description_width': '150px'})
    summary_box = widgets.VBox([widgets.HTML("<b>Summary Statistics for Proportions:</b>"),
                                s1_prop, s1_size, s2_prop, s2_size])
    
    output_area = widgets.Output()
    run_button = widgets.Button(description="Run Test", button_style='success')
    
    # Build main container row-by-row.
    def update_main_container():
        rows = []
        rows.append(mode_dd)
        rows.append(tail_dd)
        # If One Tailed is selected, add the direction dropdown as an extra row.
        if tail_dd.value == "One Tailed":
            rows.append(direction_dd)
        if mode_dd.value == "Data List":
            rows.append(data_source)
            rows.append(data_list_box)
        else:
            rows.append(summary_box)
        rows.append(sig_level_in)
        rows.append(run_button)
        rows.append(output_area)
        return widgets.VBox(rows)
    
    container = update_main_container()
    
    def update_layout(change):
        # Set the visibility of direction_dd based on tail_dd selection.
        if tail_dd.value == "One Tailed":
            direction_dd.layout.display = 'block'
        else:
            direction_dd.layout.display = 'none'
        new_container = update_main_container()
        container.children = new_container.children
    mode_dd.observe(update_layout, names='value')
    tail_dd.observe(update_layout, names='value')
    update_layout(None)
    
    def update_col_selectors(change):
        if file_upload.value:
            uploaded_file = list(file_upload.value.values())[0]
            try:
                df = pd.read_csv(pd.io.common.BytesIO(uploaded_file['content']))
            except Exception:
                try:
                    df = pd.read_excel(pd.io.common.BytesIO(uploaded_file['content']))
                except Exception as e:
                    with output_area:
                        clear_output()
                        print("Error reading file:", e)
                    return
            options = list(df.columns)
            col_sel1.options = options
            col_sel2.options = options
    file_upload.observe(update_col_selectors, 'value')
    
    def run_test_action(b):
        with output_area:
            clear_output()
            try:
                alpha = float(sig_level_in.value)
            except Exception as e:
                print("Invalid significance level:", e)
                return
            
            # Data List mode:
            if mode_dd.value == "Data List":
                if data_source.value == "Upload CSV/Excel":
                    if file_upload.value:
                        uploaded_file = list(file_upload.value.values())[0]
                        try:
                            try:
                                df = pd.read_csv(pd.io.common.BytesIO(uploaded_file['content']))
                            except:
                                df = pd.read_excel(pd.io.common.BytesIO(uploaded_file['content']))
                        except Exception as e:
                            print("Error reading file:", e)
                            return
                        col1 = col_sel1.value
                        col2 = col_sel2.value
                        try:
                            data1 = pd.to_numeric(df[col1], errors='coerce').dropna().tolist()
                            data2 = pd.to_numeric(df[col2], errors='coerce').dropna().tolist()
                        except Exception as e:
                            print("Error processing data:", e)
                            return
                    else:
                        print("Please upload a file.")
                        return
                    # Compute two-tailed p-value using proportions_ztest:
                    count1 = np.sum(np.array(data1) == 1)
                    count2 = np.sum(np.array(data2) == 1)
                    n1 = len(data1)
                    n2 = len(data2)
                    z, computed_p = proportions_ztest([count1, count2], [n1, n2], alternative='two-sided')
                else:
                    try:
                        lists_found = re.findall(r'\[([^\]]+)\]', manual_text.value)
                        if len(lists_found) != 2:
                            print("Enter exactly two lists with brackets separated by a comma.")
                            return
                        data1 = [float(x.strip()) for x in lists_found[0].split(",") if x.strip() != ""]
                        data2 = [float(x.strip()) for x in lists_found[1].split(",") if x.strip() != ""]
                    except Exception as e:
                        print("Error processing manual data:", e)
                        return
                    count1 = np.sum(np.array(data1) == 1)
                    count2 = np.sum(np.array(data2) == 1)
                    n1 = len(data1)
                    n2 = len(data2)
                    z, computed_p = proportions_ztest([count1, count2], [n1, n2], alternative='two-sided')
            else:
                count1 = s1_prop.value * s1_size.value
                count2 = s2_prop.value * s2_size.value
                n1 = s1_size.value
                n2 = s2_size.value
                z, computed_p = proportions_ztest([count1, count2], [n1, n2], alternative='two-sided')
            
            # Adjust p-value based on tail type:
            if tail_dd.value == "One Tailed":
                if direction_dd.value == "gt":
                    p = 1 - norm.cdf(z)
                    if p < alpha:
                        outcome = "Sample 1 is statistically greater than Sample 2."
                    else:
                        outcome = "There is insufficient evidence that Sample 1 is greater than Sample 2."
                else:
                    p = norm.cdf(z)
                    if p < alpha:
                        outcome = "Sample 1 is statistically less than Sample 2."
                    else:
                        outcome = "There is insufficient evidence that Sample 1 is less than Sample 2."
            else:
                p = computed_p
                if p < alpha:
                    outcome = "There is a statistically significant difference between the two samples."
                else:
                    outcome = "There is no statistically significant difference between the two samples."
            
            decision = "reject" if p < alpha else "fail to reject"
            print("Two Sample z-proportions test:")
            print("z statistic:", z)
            print("p-value:", p)
            print(outcome)
            print(f"At a significance level of {alpha}, we {decision} the null hypothesis.")
    
    run_button.on_click(run_test_action)
    
    return container



# -------------------------------------------------
# Main Container: Parent Dropdown to Select Test
# -------------------------------------------------

main_dropdown = widgets.Dropdown(
    options=["One Sample z-test", "Two Sample z-test", "One Sample z-proportions test", "Two Sample z-proportions test"],
    description="Select Test:"
)
test_container = widgets.Output()

def update_test_container(change):
    test_container.clear_output()
    with test_container:
        if main_dropdown.value == "One Sample z-test":
            display(build_one_sample_z_means_ui())
        elif main_dropdown.value == "Two Sample z-test":
            display(build_two_sample_z_means_ui())
        elif main_dropdown.value == "One Sample z-proportions test":
            display(build_one_sample_z_proportions_ui())
        elif main_dropdown.value == "Two Sample z-proportions test":
            display(build_two_sample_z_proportions_ui())

main_dropdown.observe(update_test_container, names='value')
update_test_container(None)

# -------------------------------------------------
# Display the Main UI
# -------------------------------------------------

display(widgets.VBox([main_dropdown, test_container]))

