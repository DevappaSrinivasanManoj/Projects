# @title Default title text
# Install ipywidgets if needed (uncomment if necessary)
# !pip install ipywidgets
# !jupyter nbextension enable --py widgetsnbextension

import ipywidgets as widgets
from ipywidgets import VBox, HBox, Tab, Layout
import numpy as np
import sympy as sp
import math
from IPython.display import display

# Helper: Check if an expression contains any trigonometric functions
def contains_trig(expr):
    trig_funcs = [sp.sin, sp.cos, sp.tan, sp.csc, sp.sec, sp.cot]
    return any(expr.has(func) for func in trig_funcs)

####################################
# MATRIX OPERATIONS TAB
####################################

matrix_op_dropdown = widgets.Dropdown(
    options=["Addition", "Multiplication", "Inverse", "Determinant"],
    description="Matrix Operation:",
    style={'description_width': '150px'},
    layout=Layout(width='400px')
)

matrix_textarea_A = widgets.Textarea(
    value="1,2,3;4,5,6",
    description="Matrix A:",
    layout=Layout(width='400px', height='100px'),
    style={'description_width': '100px'}
)
matrix_textarea_B = widgets.Textarea(
    value="7,8,9;10,11,12",
    description="Matrix B:",
    layout=Layout(width='400px', height='100px'),
    style={'description_width': '100px'}
)
matrix_textarea = widgets.Textarea(
    value="1,2,3;4,5,6",
    description="Matrix:",
    layout=Layout(width='400px', height='100px'),
    style={'description_width': '100px'}
)

matrix_input_box = VBox()

def update_matrix_inputs(*args):
    op = matrix_op_dropdown.value
    if op in ["Addition", "Multiplication"]:
        matrix_input_box.children = [matrix_textarea_A, matrix_textarea_B]
    else:
        matrix_input_box.children = [matrix_textarea]

update_matrix_inputs()
matrix_op_dropdown.observe(update_matrix_inputs, names="value")

matrix_output = widgets.Output()

def parse_matrix(text):
    try:
        rows = text.strip().split(";")
        matrix = [list(map(float, row.split(","))) for row in rows]
        return np.array(matrix)
    except Exception as e:
        raise ValueError("Invalid matrix format. Use rows separated by ';' and elements by ','.")

def calculate_matrix_operation(b):
    matrix_output.clear_output()
    with matrix_output:
        try:
            op = matrix_op_dropdown.value
            if op in ["Addition", "Multiplication"]:
                A = parse_matrix(matrix_textarea_A.value)
                B = parse_matrix(matrix_textarea_B.value)
                result = A + B if op == "Addition" else np.matmul(A, B)
            else:
                M = parse_matrix(matrix_textarea.value)
                result = np.linalg.inv(M) if op == "Inverse" else np.linalg.det(M)
            print("Result:")
            print(result)
        except Exception as e:
            print("Error:", e)

matrix_calc_button = widgets.Button(
    description="Calculate",
    button_style="success",
    layout=Layout(width='150px')
)
matrix_calc_button.on_click(calculate_matrix_operation)

matrix_tab_ui = VBox([
    matrix_op_dropdown,
    matrix_input_box,
    matrix_calc_button,
    matrix_output
], layout=Layout(margin='10px 0px'))

####################################
# EQUATION SOLVER TAB
####################################

equation_solver_dropdown = widgets.Dropdown(
    options=["2 Variables", "3 Variables", "Quadratic Equation", "Cubic Equation"],
    description="Equation Type:",
    style={'description_width': '150px'},
    layout=Layout(width='400px')
)

# 2 Variables: a1*x + b1*y = c1 and a2*x + b2*y = c2
a1_2 = widgets.FloatText(description="a1:", layout=Layout(width='150px'))
b1_2 = widgets.FloatText(description="b1:", layout=Layout(width='150px'))
c1_2 = widgets.FloatText(description="c1:", layout=Layout(width='150px'))
a2_2 = widgets.FloatText(description="a2:", layout=Layout(width='150px'))
b2_2 = widgets.FloatText(description="b2:", layout=Layout(width='150px'))
c2_2 = widgets.FloatText(description="c2:", layout=Layout(width='150px'))
two_vars_box = VBox([
    HBox([a1_2, b1_2, c1_2]),
    HBox([a2_2, b2_2, c2_2])
])

# 3 Variables: a1*x + b1*y + c1*z = d1, etc.
a1_3 = widgets.FloatText(description="a1:", layout=Layout(width='150px'))
b1_3 = widgets.FloatText(description="b1:", layout=Layout(width='150px'))
c1_3 = widgets.FloatText(description="c1:", layout=Layout(width='150px'))
d1_3 = widgets.FloatText(description="d1:", layout=Layout(width='150px'))
a2_3 = widgets.FloatText(description="a2:", layout=Layout(width='150px'))
b2_3 = widgets.FloatText(description="b2:", layout=Layout(width='150px'))
c2_3 = widgets.FloatText(description="c2:", layout=Layout(width='150px'))
d2_3 = widgets.FloatText(description="d2:", layout=Layout(width='150px'))
a3_3 = widgets.FloatText(description="a3:", layout=Layout(width='150px'))
b3_3 = widgets.FloatText(description="b3:", layout=Layout(width='150px'))
c3_3 = widgets.FloatText(description="c3:", layout=Layout(width='150px'))
d3_3 = widgets.FloatText(description="d3:", layout=Layout(width='150px'))
three_vars_box = VBox([
    HBox([a1_3, b1_3, c1_3, d1_3]),
    HBox([a2_3, b2_3, c2_3, d2_3]),
    HBox([a3_3, b3_3, c3_3, d3_3])
])

# Quadratic Equation: a*x^2 + b*x + c = 0
a_quad = widgets.FloatText(description="a:", layout=Layout(width='150px'))
b_quad = widgets.FloatText(description="b:", layout=Layout(width='150px'))
c_quad = widgets.FloatText(description="c:", layout=Layout(width='150px'))
quad_box = HBox([a_quad, b_quad, c_quad])

# Cubic Equation: a*x^3 + b*x^2 + c*x + d = 0
a_cubic = widgets.FloatText(description="a:", layout=Layout(width='150px'))
b_cubic = widgets.FloatText(description="b:", layout=Layout(width='150px'))
c_cubic = widgets.FloatText(description="c:", layout=Layout(width='150px'))
d_cubic = widgets.FloatText(description="d:", layout=Layout(width='150px'))
cubic_box = HBox([a_cubic, b_cubic, c_cubic, d_cubic])

equation_input_box = VBox()

def update_equation_inputs(*args):
    eq_type = equation_solver_dropdown.value
    if eq_type == "2 Variables":
        equation_input_box.children = [two_vars_box]
    elif eq_type == "3 Variables":
        equation_input_box.children = [three_vars_box]
    elif eq_type == "Quadratic Equation":
        equation_input_box.children = [quad_box]
    else:
        equation_input_box.children = [cubic_box]

update_equation_inputs()
equation_solver_dropdown.observe(update_equation_inputs, names="value")

eq_output = widgets.Output()

def solve_equation(b):
    eq_output.clear_output()
    with eq_output:
        x, y, z = sp.symbols('x y z')
        eq_type = equation_solver_dropdown.value
        try:
            if eq_type == "2 Variables":
                eq1 = sp.Eq(a1_2.value*x + b1_2.value*y, c1_2.value)
                eq2 = sp.Eq(a2_2.value*x + b2_2.value*y, c2_2.value)
                sol = sp.solve([eq1, eq2], (x, y))
            elif eq_type == "3 Variables":
                eq1 = sp.Eq(a1_3.value*x + b1_3.value*y + c1_3.value*z, d1_3.value)
                eq2 = sp.Eq(a2_3.value*x + b2_3.value*y + c2_3.value*z, d2_3.value)
                eq3 = sp.Eq(a3_3.value*x + b3_3.value*y + c3_3.value*z, d3_3.value)
                sol = sp.solve([eq1, eq2, eq3], (x, y, z))
            elif eq_type == "Quadratic Equation":
                sol = sp.solve(a_quad.value*x**2 + b_quad.value*x + c_quad.value, x)
            else:
                sol = sp.solve(a_cubic.value*x**3 + b_cubic.value*x**2 + c_cubic.value*x + d_cubic.value, x)
            print("Solution:", sol)
        except Exception as e:
            print("Error:", e)

eq_solve_button = widgets.Button(
    description="Solve",
    button_style="success",
    layout=Layout(width='150px')
)
eq_solve_button.on_click(solve_equation)

eq_solver_ui = VBox([
    equation_solver_dropdown,
    equation_input_box,
    eq_solve_button,
    eq_output
], layout=Layout(margin='10px 0px'))

####################################
# INTEGRAL CALCULATOR TAB
####################################

integral_function = widgets.Textarea(
    value="x**2",
    description="f(x):",
    layout=Layout(width='400px', height='100px'),
    style={'description_width': '80px'}
)

def append_to_integral(btn):
    integral_function.value += btn.description

integral_buttons = [
    widgets.Button(description="sin(", layout=Layout(width='60px')),
    widgets.Button(description="cos(", layout=Layout(width='60px')),
    widgets.Button(description="tan(", layout=Layout(width='60px')),
    widgets.Button(description="exp(", layout=Layout(width='60px')),
    widgets.Button(description="log(", layout=Layout(width='60px')),
    widgets.Button(description="sqrt(", layout=Layout(width='60px')),
    widgets.Button(description="^", layout=Layout(width='40px'))
]
for btn in integral_buttons:
    btn.on_click(append_to_integral)
integral_buttons_box = HBox(integral_buttons)

integral_lower = widgets.FloatText(
    value=0.0,
    description="Lower Limit:",
    layout=Layout(width='200px'),
    style={'description_width': '100px'}
)
integral_upper = widgets.FloatText(
    value=2.0,
    description="Upper Limit:",
    layout=Layout(width='200px'),
    style={'description_width': '100px'}
)

# For integrals, the "angle unit" applies only if the function contains trigonometric functions.
integral_angle_unit = widgets.RadioButtons(
    options=["Degrees", "Radians"],
    value="Degrees",
    description="Angle Unit:",
    layout=Layout(width='200px'),
    style={'description_width': '100px'}
)

integral_calc_button = widgets.Button(
    description="Calculate Integral",
    button_style="success",
    layout=Layout(width='200px')
)
integral_output = widgets.Output()

def calculate_integral(b):
    integral_output.clear_output()
    with integral_output:
        try:
            x = sp.symbols('x')
            expr = sp.sympify(integral_function.value, convert_xor=True)
            # Only substitute x if the expression contains a trig function and the unit is Degrees.
            if integral_angle_unit.value == "Degrees" and contains_trig(expr):
                expr = expr.subs(x, sp.pi/180 * x)
            lower = integral_lower.value
            upper = integral_upper.value
            result = sp.integrate(expr, (x, lower, upper))
            result_numeric = sp.N(result)  # Evaluate to numeric value
            print("Integral:", result_numeric)
        except Exception as e:
            print("Error:", e)

integral_calc_button.on_click(calculate_integral)

integral_ui = VBox([
    integral_function,
    integral_buttons_box,
    HBox([integral_lower, integral_upper]),
    integral_angle_unit,
    integral_calc_button,
    integral_output
], layout=Layout(margin='10px 0px'))

####################################
# MAXIMA/MINIMA CALCULATOR TAB
####################################

extrema_function = widgets.Textarea(
    value="x**2",
    description="f(x):",
    layout=Layout(width='400px', height='100px'),
    style={'description_width': '80px'}
)

def append_to_extrema(btn):
    extrema_function.value += btn.description

ext_buttons = [
    widgets.Button(description="sin(", layout=Layout(width='60px')),
    widgets.Button(description="cos(", layout=Layout(width='60px')),
    widgets.Button(description="tan(", layout=Layout(width='60px')),
    widgets.Button(description="exp(", layout=Layout(width='60px')),
    widgets.Button(description="log(", layout=Layout(width='60px')),
    widgets.Button(description="sqrt(", layout=Layout(width='60px')),
    widgets.Button(description="^", layout=Layout(width='40px'))
]
for btn in ext_buttons:
    btn.on_click(append_to_extrema)
ext_buttons_box = HBox(ext_buttons)

ext_lower = widgets.FloatText(
    value=-50,
    description="Lower Bound:",
    layout=Layout(width='200px'),
    style={'description_width': '100px'}
)
ext_upper = widgets.FloatText(
    value=50,
    description="Upper Bound:",
    layout=Layout(width='200px'),
    style={'description_width': '100px'}
)

ext_angle_unit = widgets.RadioButtons(
    options=["Degrees", "Radians"],
    value="Degrees",
    description="Angle Unit:",
    layout=Layout(width='200px'),
    style={'description_width': '100px'}
)

ext_calc_button = widgets.Button(
    description="Find Extrema",
    button_style="success",
    layout=Layout(width='150px')
)
ext_output = widgets.Output()

def calculate_extrema(b):
    ext_output.clear_output()
    with ext_output:
        try:
            import numpy as np
            # Parse the function using sympy
            x = sp.symbols('x', real=True)
            f_expr = sp.sympify(extrema_function.value, convert_xor=True)
            lower_bound = float(ext_lower.value)
            upper_bound = float(ext_upper.value)

            # Define a numerical function that respects the selected angle unit.
            if (ext_angle_unit.value == "Degrees" and
                any(f_expr.has(func) for func in [sp.sin, sp.cos, sp.tan, sp.csc, sp.sec, sp.cot])):
                f_lambda = sp.lambdify(x, f_expr, "numpy")
                def f_num(deg):
                    return f_lambda(np.deg2rad(deg))
            else:
                f_num = sp.lambdify(x, f_expr, "numpy")

            # Create a dense grid over the interval.
            xs = np.linspace(lower_bound, upper_bound, 10000)
            ys = f_num(xs)

            # Get the indices from the grid.
            min_idx = np.argmin(ys)
            max_idx = np.argmax(ys)

            # Start candidate set with the grid-found extrema and endpoints.
            candidates = [xs[min_idx], xs[max_idx], lower_bound, upper_bound]

            # If using degrees and a trig function, explicitly add common angles.
            if ext_angle_unit.value == "Degrees" and any(f_expr.has(func) for func in
                                                         [sp.sin, sp.cos, sp.tan, sp.csc, sp.sec, sp.cot]):
                for pt in [-90, 0, 90]:
                    if lower_bound <= pt <= upper_bound:
                        candidates.append(pt)

            # Remove duplicates (using np.unique) and evaluate f at each candidate.
            candidate_vals = {}
            for cand in np.unique(candidates):
                try:
                    val = f_num(cand)
                    candidate_vals[cand] = float(val)
                except Exception as e:
                    print("Error evaluating candidate", cand, ":", e)

            if not candidate_vals:
                print("No valid candidates found.")
                return

            min_candidate = min(candidate_vals.items(), key=lambda t: t[1])
            max_candidate = max(candidate_vals.items(), key=lambda t: t[1])
            print("Minimum at x =", min_candidate[0], "with value =", min_candidate[1])
            print("Maximum at x =", max_candidate[0], "with value =", max_candidate[1])
        except Exception as e:
            print("Error:", e)

ext_calc_button.on_click(calculate_extrema)

extrema_ui = VBox([
    extrema_function,
    ext_buttons_box,
    HBox([ext_lower, ext_upper]),
    ext_angle_unit,
    ext_calc_button,
    ext_output
], layout=Layout(margin='10px 0px'))

####################################
# ASSEMBLE ALL TABS
####################################

all_tabs = Tab(children=[matrix_tab_ui, eq_solver_ui, integral_ui, extrema_ui])
all_tabs.set_title(0, "Matrix Ops")
all_tabs.set_title(1, "Eq Solver")
all_tabs.set_title(2, "Integral")
all_tabs.set_title(3, "Extrema")
display(all_tabs)

