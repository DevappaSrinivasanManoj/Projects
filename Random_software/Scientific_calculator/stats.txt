# @title Default title text
# Install ipywidgets if needed (uncomment the next two lines if running in an environment without ipywidgets)
# !pip install ipywidgets
# !jupyter nbextension enable --py widgetsnbextension

import ipywidgets as widgets
from ipywidgets import VBox, HBox, Tab, Layout
import numpy as np
from scipy.stats import norm, binom, poisson, expon, uniform, geom, hypergeom
import math
from IPython.display import display

####################################
# Distribution Calculator UI Section
####################################

# Distribution selection widget
dist_dropdown = widgets.Dropdown(
    options=[
        ("Normal Distribution", "normal"),
        ("Binomial Distribution", "binomial"),
        ("Poisson Distribution", "poisson"),
        ("Exponential Distribution", "exponential"),
        ("Uniform Distribution", "uniform"),
        ("Geometric Distribution", "geometric"),
        ("Hypergeometric Distribution", "hypergeometric"),
        ("Beta Distribution", "beta")
    ],
    description="Distribution:",
    style={'description_width': 'initial'}
)

# Function type widget: Choose which function to compute
# (New options "PPF" and "ISF" have been added.)
func_dropdown = widgets.Dropdown(
    options=[
        ("CDF", "cdf"),
        ("1 - CDF", "one_minus_cdf"),
        ("PDF/PMF", "pdf"),
        ("PPF", "ppf"),
        ("ISF", "isf")
    ],
    description="Function Type:",
    style={'description_width': 'initial'}
)

# Container for parameter widgets (will be updated based on distribution)
param_box = VBox([])

# For normal distribution extra input mode
# (This widget will only be used when dist == "normal")
normal_mode = widgets.ToggleButtons(
    options=["Raw", "Z-score", "Percentile"],
    description="Normal Input Mode:",
    style={'description_width': 'initial'},
    layout=Layout(width='400px')
)
# Container for normal-specific parameter inputs
normal_param_box = VBox([], layout=Layout(margin='10px 0px'))

def update_normal_params(*args):
    """Update the parameter widgets for Normal distribution based on the chosen input mode."""
    mode = normal_mode.value
    if mode == "Raw":
        mean_widget = widgets.FloatText(description="Mean (μ):", value=0.0, layout=Layout(width='300px'))
        std_widget = widgets.FloatText(description="Std Dev (σ):", value=1.0, layout=Layout(width='300px'))
        x_widget = widgets.FloatText(description="x:", value=0.0, layout=Layout(width='300px'))
        normal_param_box.children = [mean_widget, std_widget, x_widget]
    elif mode == "Z-score":
        z_widget = widgets.FloatText(description="z-score:", value=0.0, layout=Layout(width='300px'))
        normal_param_box.children = [z_widget]
    elif mode == "Percentile":
        perc_widget = widgets.BoundedFloatText(description="Percentile:", min=0.0, max=1.0, step=0.01, value=0.5, layout=Layout(width='300px'))
        normal_param_box.children = [perc_widget]

# Update normal-specific parameters when mode changes
normal_mode.observe(update_normal_params, names="value")
update_normal_params()  # initialize with default ("Raw")

def update_params(*args):
    """Update parameter widgets based on the chosen distribution."""
    dist = dist_dropdown.value
    widgets_list = []

    if dist == "normal":
        # For normal distribution, include the extra input mode toggle and container
        widgets_list = [normal_mode, normal_param_box]
    elif dist == "binomial":
        n_widget = widgets.IntText(description="n (trials):", value=10, layout=Layout(width='300px'))
        p_widget = widgets.BoundedFloatText(description="p (prob):", min=0.0, max=1.0, step=0.01, value=0.5, layout=Layout(width='300px'))
        x_widget = widgets.IntText(description="x (successes):", value=5, layout=Layout(width='300px'), style={'description_width': '150px'})
        widgets_list = [n_widget, p_widget, x_widget]
    elif dist == "poisson":
        lam_widget = widgets.FloatText(description="λ (rate):", value=3.0, layout=Layout(width='300px'))
        x_widget = widgets.IntText(description="x:", value=2, layout=Layout(width='300px'))
        widgets_list = [lam_widget, x_widget]
    elif dist == "exponential":
        lam_widget = widgets.FloatText(description="λ (rate):", value=1.0, layout=Layout(width='300px'))
        x_widget = widgets.FloatText(description="x:", value=0.0, layout=Layout(width='300px'))
        widgets_list = [lam_widget, x_widget]
    elif dist == "uniform":
        lower_widget = widgets.FloatText(description="Lower bound (a):", value=0.0, layout=Layout(width='300px'), style={'description_width': '150px'})
        upper_widget = widgets.FloatText(description="Upper bound (b):", value=1.0, layout=Layout(width='300px'), style={'description_width': '150px'})
        x_widget = widgets.FloatText(description="x:", value=0.5, layout=Layout(width='300px'))
        widgets_list = [lower_widget, upper_widget, x_widget]
    elif dist == "geometric":
        p_widget = widgets.BoundedFloatText(description="p (prob):", min=0.0, max=1.0, step=0.01, value=0.5, layout=Layout(width='300px'))
        x_widget = widgets.IntText(description="x (trial number):", value=1, layout=Layout(width='300px'), style={'description_width': '150px'})
        widgets_list = [p_widget, x_widget]
    elif dist == "hypergeometric":
        N_widget = widgets.IntText(description="Population size (N):", value=50, layout=Layout(width='300px'), style={'description_width': '150px'})
        K_widget = widgets.IntText(description="Successes in population (K):", value=10, layout=Layout(width='300px'), style={'description_width': '200px'})
        n_widget = widgets.IntText(description="Sample size (n):", value=5, layout=Layout(width='300px'), style={'description_width': '150px'})
        x_widget = widgets.IntText(description="x (successes in sample):", value=2, layout=Layout(width='300px'), style={'description_width': '150px'})
        widgets_list = [N_widget, K_widget, n_widget, x_widget]
    elif dist == "beta":
        a_widget = widgets.FloatText(description="α (shape1):", value=2.0, layout=Layout(width='300px'), style={'description_width': '150px'})
        b_widget = widgets.FloatText(description="β (shape2):", value=5.0, layout=Layout(width='300px'), style={'description_width': '150px'})
        x_widget = widgets.FloatText(description="x:", value=0.5, layout=Layout(width='300px'), style={'description_width': '150px'})
        widgets_list = [a_widget, b_widget, x_widget]

    param_box.children = widgets_list

# Update parameters initially and when distribution selection changes
update_params()
dist_dropdown.observe(update_params, names="value")

# Output widget for displaying the result of the distribution calculation
dist_output = widgets.Output()

def calc_distribution(b):
    dist_output.clear_output()
    with dist_output:
        try:
            dist = dist_dropdown.value
            func_type = func_dropdown.value
            result = None

            if dist == "normal":
                # For normal distribution, check the input mode
                mode = normal_mode.value
                if mode == "Raw":
                    # Expecting [Mean, Std Dev, x]
                    mean = normal_param_box.children[0].value
                    std = normal_param_box.children[1].value
                    x_val = normal_param_box.children[2].value
                    d = norm(loc=mean, scale=std)
                    if func_type == "cdf":
                        result = d.cdf(x_val)
                    elif func_type == "one_minus_cdf":
                        result = 1 - d.cdf(x_val)
                    elif func_type == "pdf":
                        result = d.pdf(x_val)
                    elif func_type == "ppf":
                        result = d.ppf(x_val)
                    elif func_type == "isf":
                        result = d.isf(x_val)
                    print(f"Result: {result}")
                elif mode == "Z-score":
                    # Expecting [z-score]
                    z_val = normal_param_box.children[0].value
                    d = norm(0, 1)
                    if func_type == "cdf":
                        result = d.cdf(z_val)
                    elif func_type == "one_minus_cdf":
                        result = 1 - d.cdf(z_val)
                    elif func_type == "pdf":
                        result = d.pdf(z_val)
                    elif func_type == "ppf":
                        result = d.ppf(z_val)
                    elif func_type == "isf":
                        result = d.isf(z_val)
                    print(f"Result (Standard Normal at input={z_val}): {result}")
                elif mode == "Percentile":
                    # Expecting [Percentile] to convert to z-score using ppf (this mode always computes the inverse CDF)
                    perc = normal_param_box.children[0].value
                    z_val = norm.ppf(perc)
                    print(f"Percentile {perc} corresponds to z-score: {z_val}")
            elif dist == "binomial":
                n = param_box.children[0].value
                p = param_box.children[1].value
                x = param_box.children[2].value
                d = binom(n, p)
                if func_type == "cdf":
                    result = d.cdf(x)
                elif func_type == "one_minus_cdf":
                    result = 1 - d.cdf(x)
                elif func_type == "pdf":
                    result = d.pmf(x)
                elif func_type == "ppf":
                    result = d.ppf(x)
                elif func_type == "isf":
                    result = d.isf(x)
                print(f"Result: {result}")
            elif dist == "poisson":
                lam = param_box.children[0].value
                x = param_box.children[1].value
                d = poisson(lam)
                if func_type == "cdf":
                    result = d.cdf(x)
                elif func_type == "one_minus_cdf":
                    result = 1 - d.cdf(x)
                elif func_type == "pdf":
                    result = d.pmf(x)
                elif func_type == "ppf":
                    result = d.ppf(x)
                elif func_type == "isf":
                    result = d.isf(x)
                print(f"Result: {result}")
            elif dist == "exponential":
                lam = param_box.children[0].value
                x = param_box.children[1].value
                d = expon(scale=1/lam)
                if func_type == "cdf":
                    result = d.cdf(x)
                elif func_type == "one_minus_cdf":
                    result = 1 - d.cdf(x)
                elif func_type == "pdf":
                    result = d.pdf(x)
                elif func_type == "ppf":
                    result = d.ppf(x)
                elif func_type == "isf":
                    result = d.isf(x)
                print(f"Result: {result}")
            elif dist == "uniform":
                a = param_box.children[0].value
                b_val = param_box.children[1].value
                if b_val <= a:
                    raise ValueError("Upper bound must be greater than lower bound.")
                x = param_box.children[2].value
                d = uniform(loc=a, scale=b_val - a)
                if func_type == "cdf":
                    result = d.cdf(x)
                elif func_type == "one_minus_cdf":
                    result = 1 - d.cdf(x)
                elif func_type == "pdf":
                    result = d.pdf(x)
                elif func_type == "ppf":
                    result = d.ppf(x)
                elif func_type == "isf":
                    result = d.isf(x)
                print(f"Result: {result}")
            elif dist == "geometric":
                p = param_box.children[0].value
                x = param_box.children[1].value
                d = geom(p)
                if func_type == "cdf":
                    result = d.cdf(x)
                elif func_type == "one_minus_cdf":
                    result = 1 - d.cdf(x)
                elif func_type == "pdf":
                    result = d.pmf(x)
                elif func_type == "ppf":
                    result = d.ppf(x)
                elif func_type == "isf":
                    result = d.isf(x)
                print(f"Result: {result}")
            elif dist == "hypergeometric":
                N = param_box.children[0].value
                K = param_box.children[1].value
                n = param_box.children[2].value
                x = param_box.children[3].value
                d = hypergeom(N, K, n)
                if func_type == "cdf":
                    result = d.cdf(x)
                elif func_type == "one_minus_cdf":
                    result = 1 - d.cdf(x)
                elif func_type == "pdf":
                    result = d.pmf(x)
                elif func_type == "ppf":
                    result = d.ppf(x)
                elif func_type == "isf":
                    result = d.isf(x)
                print(f"Result: {result}")
            elif dist == "beta":
                a_val = param_box.children[0].value
                b_val = param_box.children[1].value
                x = param_box.children[2].value
                from scipy.stats import beta
                d = beta(a_val, b_val)
                if func_type == "cdf":
                    result = d.cdf(x)
                elif func_type == "one_minus_cdf":
                    result = 1 - d.cdf(x)
                elif func_type == "pdf":
                    result = d.pdf(x)
                elif func_type == "ppf":
                    result = d.ppf(x)
                elif func_type == "isf":
                    result = d.isf(x)
                print(f"Result: {result}")
        except Exception as e:
            print(f"Error: {e}")

# Button to trigger distribution calculation
calc_button = widgets.Button(description="Calculate", button_style="success", layout=Layout(width='150px'))
calc_button.on_click(calc_distribution)

# Assemble Distribution Calculator UI
dist_calculator_ui = VBox([
    dist_dropdown,
    func_dropdown,
    param_box,
    calc_button,
    dist_output
], layout=Layout(margin='10px 0px'))

####################################
# Conversion Calculator UI Section
####################################

# Conversion category: either convert a single value or convert parameters.
conv_category = widgets.RadioButtons(
    options=["Value Conversion", "Parameter Conversion"],
    description="Conversion Category:",
    style={'description_width': 'initial'},
    layout=Layout(width='400px')
)

# Container to hold the inner conversion UI (which changes based on category)
conv_inner_box = VBox([], layout=Layout(margin='10px 0px'))

# --- For Value Conversion ---
conv_radio_value = widgets.RadioButtons(
    options=[("Normal to Lognormal", "normal_to_lognormal"), ("Lognormal to Normal", "lognormal_to_normal")],
    description="Value Conversion:",
    style={'description_width': 'initial'},
    layout=Layout(width='400px')
)
conv_value_input = widgets.FloatText(
    description="Value:",
    value=0.0,
    layout=Layout(width='300px')
)
value_conv_ui = VBox([conv_radio_value, conv_value_input], layout=Layout(margin='10px 0px'))

# --- For Parameter Conversion ---
parameter_conv_radio = widgets.RadioButtons(
    options=[("Lognormal to Normal Parameters", "normal_to_lognormal_params"),
             ("Normal to Lognormal Parameters", "lognormal_to_normal_params")],
    description="Parameter Conversion:",
    style={'description_width': 'initial'},
    layout=Layout(width='400px')
)
# Containers for the parameter inputs with fixed width and margin
normal_param_inputs = VBox([
    widgets.FloatText(description="Lognormal Mean (m):", value=0.0, layout=Layout(width='300px'), style={'description_width': '150px'}),
    widgets.FloatText(description="Lognormal Std Dev:", value=1.0, layout=Layout(width='300px'), style={'description_width': '150px'})
], layout=Layout(margin='10px 0px'))
lognormal_param_inputs = VBox([
    widgets.FloatText(description="Normal Mean (μ):", value=1.0, layout=Layout(width='300px'), style={'description_width': '150px'}),
    widgets.FloatText(description="Normal Variance:", value=0.5, layout=Layout(width='300px'), style={'description_width': '150px'})
], layout=Layout(margin='10px 0px'))
# Container that will hold one of the above based on the radio selection.
param_conv_input_box = VBox([], layout=Layout(margin='10px 0px'))

def update_param_conv_inputs(*args):
    """Update parameter conversion inputs based on chosen conversion type."""
    if parameter_conv_radio.value == "normal_to_lognormal_params":
        param_conv_input_box.children = [normal_param_inputs]
    else:
        param_conv_input_box.children = [lognormal_param_inputs]

parameter_conv_radio.observe(update_param_conv_inputs, names="value")
update_param_conv_inputs()

parameter_conv_ui = VBox([parameter_conv_radio, param_conv_input_box], layout=Layout(margin='10px 0px'))

def update_conv_inner(*args):
    """Update the inner conversion UI based on conversion category."""
    if conv_category.value == "Value Conversion":
        conv_inner_box.children = [value_conv_ui]
    else:
        conv_inner_box.children = [parameter_conv_ui]

conv_category.observe(update_conv_inner, names="value")
update_conv_inner()

# Output widget for conversion results
conv_output = widgets.Output()

# Button for performing conversion
conv_button = widgets.Button(description="Convert", button_style="info", layout=Layout(width='150px'))

def perform_conversion(b):
    conv_output.clear_output()
    with conv_output:
        try:
            if conv_category.value == "Value Conversion":
                val = conv_value_input.value
                if conv_radio_value.value == "normal_to_lognormal":
                    # Single value conversion: normal to lognormal using exp.
                    result = math.exp(val)
                    print(f"exp({val}) = {result}")
                else:
                    # Lognormal to normal using log.
                    if val <= 0:
                        raise ValueError("Value must be positive for log conversion.")
                    result = math.log(val)
                    print(f"log({val}) = {result}")
            else:
                # Parameter Conversion
                if parameter_conv_radio.value == "normal_to_lognormal_params":
                    mu = normal_param_inputs.children[0].value
                    sigma = normal_param_inputs.children[1].value
                    lognorm_mean = math.exp(mu + sigma**2 / 2)
                    lognorm_variance = (math.exp(sigma**2) - 1) * math.exp(2*mu + sigma**2)
                    print(f"Given Lognormal parameters: μ = {mu}, σ = {sigma}")
                    print(f"Equivalent Normal Mean: {lognorm_mean}")
                    print(f"Equivalent Normal Variance: {lognorm_variance}")
                else:
                    m = lognormal_param_inputs.children[0].value
                    v = lognormal_param_inputs.children[1].value
                    if m <= 0:
                        raise ValueError("Lognormal mean must be positive.")
                    sigma2 = math.log(1 + v/(m**2))
                    sigma = math.sqrt(sigma2)
                    mu = math.log(m) - sigma2/2
                    print(f"Given Normal parameters: Mean = {m}, Variance = {v}")
                    print(f"Lognormal Mean: {mu}")
                    print(f"Lognormal Std Dev: {sigma}")
        except Exception as e:
            print(f"Error: {e}")

conv_button.on_click(perform_conversion)

# Assemble Conversion Calculator UI
conv_calculator_ui = VBox([
    conv_category,
    conv_inner_box,
    conv_button,
    conv_output
], layout=Layout(margin='10px 0px'))

####################################
# Create Tabs for the Two Calculators
####################################

tab = Tab(children=[dist_calculator_ui, conv_calculator_ui])
tab.set_title(0, "Distributions")
tab.set_title(1, "Conversion")
display(tab)

