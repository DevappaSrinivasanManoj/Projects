<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MetrTrack - Modern Meter Reading Tracker</title>
    <style>
        :root {
            --primary-color: #4361ee;
            --secondary-color: #3a0ca3;
            --accent-color: #4cc9f0;
            --success-color: #2ec4b6;
            --warning-color: #ff9f1c;
            --danger-color: #e71d36;
            --dark-color: #1a1a2e;
            --light-color: #f8f9fa;
            --gray-color: #6c757d;
            --border-radius: 12px;
            --box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #f5f7fa;
            color: var(--dark-color);
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 1.5rem;
            text-align: center;
            box-shadow: var(--box-shadow);
        }

        .app-title {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        .app-subtitle {
            font-size: 1rem;
            opacity: 0.9;
        }

        main {
            flex: 1;
            padding: 1.5rem;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
        }

        @media (min-width: 768px) {
            .container {
                grid-template-columns: 1fr 1fr;
            }
        }

        .card {
            background-color: white;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            padding: 1.5rem;
            transition: var(--transition);
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.15);
        }

        .card-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--dark-color);
        }

        input, select, textarea {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            font-size: 1rem;
            transition: var(--transition);
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.2);
        }

        .btn {
            display: inline-block;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            text-align: center;
        }

        .btn:hover {
            background-color: var(--secondary-color);
            transform: translateY(-2px);
        }

        .btn-block {
            display: block;
            width: 100%;
        }

        .btn-success {
            background-color: var(--success-color);
        }

        .btn-success:hover {
            background-color: #25a599;
        }

        .btn-danger {
            background-color: var(--danger-color);
        }

        .btn-danger:hover {
            background-color: #c91b2e;
        }

        .btn-warning {
            background-color: var(--warning-color);
        }

        .btn-warning:hover {
            background-color: #e08c19;
        }

        .btn-group {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .btn-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .readings-list {
            margin-top: 1rem;
            max-height: 400px;
            overflow-y: auto;
            border-radius: var(--border-radius);
            border: 1px solid #eee;
        }

        .reading-item {
            padding: 1rem;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: var(--transition);
        }

        .reading-item:last-child {
            border-bottom: none;
        }

        .reading-item:hover {
            background-color: #f8f9fa;
        }

        .reading-info {
            flex: 1;
        }

        .reading-value {
            font-weight: 600;
            font-size: 1.1rem;
            color: var(--primary-color);
        }

        .reading-date {
            font-size: 0.85rem;
            color: var(--gray-color);
        }

        .reading-actions {
            display: flex;
            gap: 0.5rem;
        }

        .action-btn {
            background: none;
            border: none;
            cursor: pointer;
            color: var(--gray-color);
            transition: var(--transition);
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: 50%;
        }

        .action-btn:hover {
            background-color: #f0f0f0;
            color: var(--primary-color);
        }

        .action-btn.delete:hover {
            color: var(--danger-color);
        }

        .action-btn.edit:hover {
            color: var(--warning-color);
        }

        .tabs {
            display: flex;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid #eee;
        }

        .tab {
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            transition: var(--transition);
            border-bottom: 2px solid transparent;
        }

        .tab.active {
            border-bottom: 2px solid var(--primary-color);
            color: var(--primary-color);
            font-weight: 500;
        }

        .tab:hover:not(.active) {
            background-color: #f8f9fa;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .meter-type-icon {
            font-size: 1.5rem;
            margin-right: 0.5rem;
        }

        .stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .stat-card {
            background-color: white;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            padding: 1rem;
            text-align: center;
            transition: var(--transition);
        }

        .stat-card:hover {
            transform: translateY(-3px);
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-color);
            margin: 0.5rem 0;
        }

        .stat-label {
            font-size: 0.9rem;
            color: var(--gray-color);
        }

        .chart-container {
            height: 300px;
            margin-top: 1.5rem;
            position: relative;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background-color: white;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            padding: 2rem;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .modal-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--primary-color);
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--gray-color);
            transition: var(--transition);
        }

        .modal-close:hover {
            color: var(--danger-color);
        }

        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: white;
            color: var(--dark-color);
            padding: 1rem 1.5rem;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            z-index: 1000;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .toast.success {
            border-left: 4px solid var(--success-color);
        }

        .toast.error {
            border-left: 4px solid var(--danger-color);
        }

        .toast.warning {
            border-left: 4px solid var(--warning-color);
        }

        .toast.info {
            border-left: 4px solid var(--primary-color);
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }

        .toast-icon {
            font-size: 1.25rem;
        }

        .toast.success .toast-icon {
            color: var(--success-color);
        }

        .toast.error .toast-icon {
            color: var(--danger-color);
        }

        .toast.warning .toast-icon {
            color: var(--warning-color);
        }

        .toast.info .toast-icon {
            color: var(--primary-color);
        }

        .empty-state {
            text-align: center;
            padding: 2rem;
            color: var(--gray-color);
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .empty-state-text {
            font-size: 1.1rem;
            margin-bottom: 1rem;
        }

        .theme-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }

        .theme-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--primary-color);
        }

        input:focus + .slider {
            box-shadow: 0 0 1px var(--primary-color);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .dark-mode {
            --primary-color: #4cc9f0;
            --secondary-color: #4361ee;
            --accent-color: #3a0ca3;
            --dark-color: #f8f9fa;
            --light-color: #1a1a2e;
            --gray-color: #adb5bd;
            background-color: #121212;
            color: var(--dark-color);
        }

        .dark-mode .card,
        .dark-mode .modal-content,
        .dark-mode .stat-card,
        .dark-mode .toast {
            background-color: #1e1e1e;
            color: var(--dark-color);
        }

        .dark-mode .reading-item:hover {
            background-color: #2a2a2a;
        }

        .dark-mode .action-btn:hover {
            background-color: #2a2a2a;
        }

        .dark-mode input, 
        .dark-mode select, 
        .dark-mode textarea {
            background-color: #2a2a2a;
            border-color: #444;
            color: var(--dark-color);
        }

        .dark-mode .tab:hover:not(.active) {
            background-color: #2a2a2a;
        }

        .dark-mode .readings-list {
            border-color: #444;
        }

        .dark-mode .reading-item {
            border-color: #444;
        }

        .dark-mode .tabs {
            border-color: #444;
        }

        footer {
            background-color: white;
            padding: 1rem;
            text-align: center;
            font-size: 0.9rem;
            color: var(--gray-color);
            margin-top: auto;
            box-shadow: 0 -5px 10px rgba(0, 0, 0, 0.05);
        }

        .dark-mode footer {
            background-color: #1e1e1e;
        }

        .settings-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #eee;
        }

        .dark-mode .settings-row {
            border-color: #444;
        }

        .settings-label {
            font-weight: 500;
        }

        .settings-description {
            font-size: 0.9rem;
            color: var(--gray-color);
            margin-top: 0.25rem;
        }

        /* Loading spinner */
        .spinner {
            width: 40px;
            height: 40px;
            margin: 100px auto;
            background-color: var(--primary-color);
            border-radius: 100%;  
            animation: sk-scaleout 1.0s infinite ease-in-out;
        }

        @keyframes sk-scaleout {
            0% { 
                transform: scale(0);
            } 100% {
                transform: scale(1.0);
                opacity: 0;
            }
        }

        /* Responsive adjustments */
        @media (max-width: 576px) {
            .btn-group {
                flex-direction: column;
            }
            
            .stats-container {
                grid-template-columns: 1fr;
            }
            
            .modal-content {
                padding: 1rem;
            }
            
            .card-title {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="app-title">MetrTrack</div>
        <div class="app-subtitle">Modern Meter Reading Tracker</div>
    </header>

    <main>
        <div class="tabs">
            <div class="tab active" data-tab="dashboard">Dashboard</div>
            <div class="tab" data-tab="readings">Readings</div>
            <div class="tab" data-tab="add">Add Reading</div>
            <div class="tab" data-tab="settings">Settings</div>
        </div>

        <div class="tab-content active" id="dashboard">
            <div class="stats-container">
                <div class="stat-card">
                    <div class="stat-label">Total Readings</div>
                    <div class="stat-value" id="total-readings">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Meter Types</div>
                    <div class="stat-value" id="meter-types">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Latest Reading</div>
                    <div class="stat-value" id="latest-reading">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Last Updated</div>
                    <div class="stat-value" id="last-updated">-</div>
                </div>
            </div>

            <div class="card">
                <div class="card-title">Recent Readings</div>
                <div id="recent-readings" class="readings-list">
                    <div class="empty-state">
                        <div class="empty-state-icon">📊</div>
                        <div class="empty-state-text">No readings yet</div>
                        <button class="btn" id="add-first-reading">Add Your First Reading</button>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="card-title">Reading Trends</div>
                <div class="chart-container" id="chart-container">
                    <canvas id="readings-chart"></canvas>
                </div>
            </div>
        </div>

        <div class="tab-content" id="readings">
            <div class="card">
                <div class="card-title">
                    <span>All Readings</span>
                    <div>
                        <select id="filter-meter-type" class="filter-select">
                            <option value="all">All Meter Types</option>
                        </select>
                    </div>
                </div>
                <div id="all-readings" class="readings-list">
                    <div class="empty-state">
                        <div class="empty-state-icon">📊</div>
                        <div class="empty-state-text">No readings yet</div>
                        <button class="btn" id="add-reading-from-list">Add Your First Reading</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="tab-content" id="add">
            <div class="card">
                <div class="card-title">Add New Reading</div>
                <form id="add-reading-form">
                    <div class="form-group">
                        <label for="meter-type">Meter Type</label>
                        <select id="meter-type" required>
                            <option value="">Select Meter Type</option>
                            <option value="bike">Bike Odometer</option>
                            <option value="bicycle">Bicycle Distance</option>
                            <option value="electric">Electric Meter</option>
                            <option value="water">Water Meter</option>
                            <option value="gas">Gas Meter</option>
                            <option value="custom">Custom Meter</option>
                        </select>
                    </div>
                    
                    <div class="form-group" id="custom-meter-container" style="display: none;">
                        <label for="custom-meter-name">Custom Meter Name</label>
                        <input type="text" id="custom-meter-name" placeholder="Enter custom meter name">
                    </div>

                    <div class="form-group">
                        <label for="meter-name">Meter Name/Label</label>
                        <input type="text" id="meter-name" placeholder="E.g., Home Electric Meter, Mountain Bike" required>
                    </div>

                    <div class="form-group">
                        <label for="reading-value">Reading Value</label>
                        <input type="number" id="reading-value" step="0.01" placeholder="Enter the meter reading value" required>
                    </div>

                    <div class="form-group">
                        <label for="reading-unit">Unit</label>
                        <input type="text" id="reading-unit" placeholder="E.g., km, kWh, m³" required>
                    </div>

                    <div class="form-group">
                        <label for="reading-date">Date & Time</label>
                        <input type="datetime-local" id="reading-date" required>
                    </div>

                    <div class="form-group">
                        <label for="reading-notes">Notes (Optional)</label>
                        <textarea id="reading-notes" rows="3" placeholder="Any additional notes about this reading"></textarea>
                    </div>

                    <button type="submit" class="btn btn-block">Save Reading</button>
                </form>
            </div>
        </div>

        <div class="tab-content" id="settings">
            <div class="card">
                <div class="card-title">App Settings</div>
                
                <div class="settings-row">
                    <div>
                        <div class="settings-label">Dark Mode</div>
                        <div class="settings-description">Switch between light and dark theme</div>
                    </div>
                    <label class="theme-switch">
                        <input type="checkbox" id="theme-toggle">
                        <span class="slider"></span>
                    </label>
                </div>

                <div class="settings-row">
                    <div>
                        <div class="settings-label">Data Management</div>
                        <div class="settings-description">Export or import your meter reading data</div>
                    </div>
                    <div class="btn-group">
                        <button class="btn" id="export-data">Export Data</button>
                        <button class="btn" id="import-data">Import Data</button>
                    </div>
                </div>

                <div class="settings-row">
                    <div>
                        <div class="settings-label">Clear All Data</div>
                        <div class="settings-description">Delete all your meter readings (cannot be undone)</div>
                    </div>
                    <button class="btn btn-danger" id="clear-data">Clear Data</button>
                </div>
            </div>
        </div>
    </main>

    <!-- Edit Reading Modal -->
    <div class="modal" id="edit-modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Edit Reading</div>
                <button class="modal-close" id="edit-modal-close">&times;</button>
            </div>
            <form id="edit-reading-form">
                <input type="hidden" id="edit-reading-id">
                <div class="form-group">
                    <label for="edit-meter-type">Meter Type</label>
                    <select id="edit-meter-type" required>
                        <option value="">Select Meter Type</option>
                        <option value="bike">Bike Odometer</option>
                        <option value="bicycle">Bicycle Distance</option>
                        <option value="electric">Electric Meter</option>
                        <option value="water">Water Meter</option>
                        <option value="gas">Gas Meter</option>
                        <option value="custom">Custom Meter</option>
                    </select>
                </div>
                
                <div class="form-group" id="edit-custom-meter-container" style="display: none;">
                    <label for="edit-custom-meter-name">Custom Meter Name</label>
                    <input type="text" id="edit-custom-meter-name" placeholder="Enter custom meter name">
                </div>

                <div class="form-group">
                    <label for="edit-meter-name">Meter Name/Label</label>
                    <input type="text" id="edit-meter-name" placeholder="E.g., Home Electric Meter, Mountain Bike" required>
                </div>

                <div class="form-group">
                    <label for="edit-reading-value">Reading Value</label>
                    <input type="number" id="edit-reading-value" step="0.01" placeholder="Enter the meter reading value" required>
                </div>

                <div class="form-group">
                    <label for="edit-reading-unit">Unit</label>
                    <input type="text" id="edit-reading-unit" placeholder="E.g., km, kWh, m³" required>
                </div>

                <div class="form-group">
                    <label for="edit-reading-date">Date & Time</label>
                    <input type="datetime-local" id="edit-reading-date" required>
                </div>

                <div class="form-group">
                    <label for="edit-reading-notes">Notes (Optional)</label>
                    <textarea id="edit-reading-notes" rows="3" placeholder="Any additional notes about this reading"></textarea>
                </div>

                <button type="submit" class="btn btn-block">Update Reading</button>
            </form>
        </div>
    </div>

    <!-- Import Data Modal -->
    <div class="modal" id="import-modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Import Data</div>
                <button class="modal-close" id="import-modal-close">&times;</button>
            </div>
            <div class="form-group">
                <label for="import-file">Select JSON File</label>
                <input type="file" id="import-file" accept=".json">
            </div>
            <div class="form-group">
                <label>Import Options</label>
                <div>
                    <input type="radio" id="import-replace" name="import-option" value="replace" checked>
                    <label for="import-replace">Replace all existing data</label>
                </div>
                <div>
                    <input type="radio" id="import-merge" name="import-option" value="merge">
                    <label for="import-merge">Merge with existing data</label>
                </div>
            </div>
            <button class="btn btn-block" id="confirm-import">Import Data</button>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div class="modal" id="confirm-modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title" id="confirm-title">Confirmation</div>
                <button class="modal-close" id="confirm-modal-close">&times;</button>
            </div>
            <p id="confirm-message">Are you sure you want to proceed?</p>
            <div class="btn-group">
                <button class="btn btn-danger" id="confirm-yes">Yes</button>
                <button class="btn" id="confirm-no">No</button>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div class="toast" id="toast">
        <div class="toast-icon" id="toast-icon">✓</div>
        <div id="toast-message">Operation successful</div>
    </div>

    <footer>
        <p>MetrTrack &copy; 2025 | Modern Meter Reading Tracker</p>
    </footer>

    <!-- Chart.js for data visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <script>
        // Main application logic
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize the app
            const app = new MeterTracker();
            app.init();
        });

        class MeterTracker {
            constructor() {
                // App state
                this.readings = [];
                this.currentTab = 'dashboard';
                this.editingReadingId = null;
                this.confirmCallback = null;
                this.chart = null;
                
                // DOM elements
                this.elements = {
                    tabs: document.querySelectorAll('.tab'),
                    tabContents: document.querySelectorAll('.tab-content'),
                    addReadingForm: document.getElementById('add-reading-form'),
                    editReadingForm: document.getElementById('edit-reading-form'),
                    meterTypeSelect: document.getElementById('meter-type'),
                    customMeterContainer: document.getElementById('custom-meter-container'),
                    editMeterTypeSelect: document.getElementById('edit-meter-type'),
                    editCustomMeterContainer: document.getElementById('edit-custom-meter-container'),
                    recentReadings: document.getElementById('recent-readings'),
                    allReadings: document.getElementById('all-readings'),
                    filterMeterType: document.getElementById('filter-meter-type'),
                    editModal: document.getElementById('edit-modal'),
                    editModalClose: document.getElementById('edit-modal-close'),
                    importModal: document.getElementById('import-modal'),
                    importModalClose: document.getElementById('import-modal-close'),
                    importFile: document.getElementById('import-file'),
                    confirmImport: document.getElementById('confirm-import'),
                    exportData: document.getElementById('export-data'),
                    importData: document.getElementById('import-data'),
                    clearData: document.getElementById('clear-data'),
                    confirmModal: document.getElementById('confirm-modal'),
                    confirmModalClose: document.getElementById('confirm-modal-close'),
                    confirmTitle: document.getElementById('confirm-title'),
                    confirmMessage: document.getElementById('confirm-message'),
                    confirmYes: document.getElementById('confirm-yes'),
                    confirmNo: document.getElementById('confirm-no'),
                    toast: document.getElementById('toast'),
                    toastIcon: document.getElementById('toast-icon'),
                    toastMessage: document.getElementById('toast-message'),
                    themeToggle: document.getElementById('theme-toggle'),
                    addFirstReading: document.getElementById('add-first-reading'),
                    addReadingFromList: document.getElementById('add-reading-from-list'),
                    totalReadings: document.getElementById('total-readings'),
                    meterTypes: document.getElementById('meter-types'),
                    latestReading: document.getElementById('latest-reading'),
                    lastUpdated: document.getElementById('last-updated'),
                    readingsChart: document.getElementById('readings-chart')
                };
            }

            init() {
                // Load data from local storage
                this.loadData();
                
                // Initialize UI
                this.initializeTabs();
                this.initializeFormHandlers();
                this.initializeModalHandlers();
                this.initializeSettingsHandlers();
                this.initializeTheme();
                
                // Render initial data
                this.renderDashboard();
                this.renderReadings();
                this.updateFilterOptions();
                
                // Set current date and time for new readings
                this.setCurrentDateTime();
            }

            // Data Management Methods
            loadData() {
                const storedData = localStorage.getItem('meterTrackData');
                if (storedData) {
                    try {
                        this.readings = JSON.parse(storedData);
                    } catch (e) {
                        console.error('Error loading data:', e);
                        this.readings = [];
                    }
                }
            }

            saveData() {
                localStorage.setItem('meterTrackData', JSON.stringify(this.readings));
            }

            addReading(reading) {
                // Generate a unique ID
                reading.id = Date.now().toString();
                
                // Add timestamp
                reading.timestamp = new Date().toISOString();
                
                // Add to readings array
                this.readings.push(reading);
                
                // Save to local storage
                this.saveData();
                
                // Update UI
                this.renderDashboard();
                this.renderReadings();
                this.updateFilterOptions();
                
                // Show success message
                this.showToast('Reading added successfully', 'success');
            }

            updateReading(id, updatedReading) {
                const index = this.readings.findIndex(r => r.id === id);
                if (index !== -1) {
                    // Preserve the ID and update timestamp
                    updatedReading.id = id;
                    updatedReading.timestamp = new Date().toISOString();
                    
                    // Update the reading
                    this.readings[index] = updatedReading;
                    
                    // Save to local storage
                    this.saveData();
                    
                    // Update UI
                    this.renderDashboard();
                    this.renderReadings();
                    this.updateFilterOptions();
                    
                    // Show success message
                    this.showToast('Reading updated successfully', 'success');
                    return true;
                }
                return false;
            }

            deleteReading(id) {
                const index = this.readings.findIndex(r => r.id === id);
                if (index !== -1) {
                    // Remove the reading
                    this.readings.splice(index, 1);
                    
                    // Save to local storage
                    this.saveData();
                    
                    // Update UI
                    this.renderDashboard();
                    this.renderReadings();
                    this.updateFilterOptions();
                    
                    // Show success message
                    this.showToast('Reading deleted successfully', 'success');
                    return true;
                }
                return false;
            }

            clearAllData() {
                this.readings = [];
                this.saveData();
                this.renderDashboard();
                this.renderReadings();
                this.updateFilterOptions();
                this.showToast('All data cleared successfully', 'success');
            }

            exportDataToJson() {
                const dataStr = JSON.stringify(this.readings, null, 2);
                const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
                
                const exportFileName = `meter-tracker-export-${new Date().toISOString().slice(0, 10)}.json`;
                
                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileName);
                linkElement.click();
                
                this.showToast('Data exported successfully', 'success');
            }

            importDataFromJson(jsonData, option) {
                try {
                    const importedData = JSON.parse(jsonData);
                    
                    // Validate imported data
                    if (!Array.isArray(importedData)) {
                        throw new Error('Invalid data format');
                    }
                    
                    // Process based on selected option
                    if (option === 'replace') {
                        this.readings = importedData;
                    } else if (option === 'merge') {
                        // Merge by ID, avoiding duplicates
                        const existingIds = new Set(this.readings.map(r => r.id));
                        for (const reading of importedData) {
                            if (!existingIds.has(reading.id)) {
                                this.readings.push(reading);
                                existingIds.add(reading.id);
                            }
                        }
                    }
                    
                    // Save and update UI
                    this.saveData();
                    this.renderDashboard();
                    this.renderReadings();
                    this.updateFilterOptions();
                    
                    this.showToast('Data imported successfully', 'success');
                    return true;
                } catch (e) {
                    console.error('Error importing data:', e);
                    this.showToast('Error importing data: ' + e.message, 'error');
                    return false;
                }
            }

            // UI Rendering Methods
            renderDashboard() {
                // Update statistics
                this.elements.totalReadings.textContent = this.readings.length;
                
                // Count unique meter types
                const uniqueMeterTypes = new Set();
                this.readings.forEach(reading => {
                    uniqueMeterTypes.add(reading.meterType === 'custom' ? reading.customMeterName : reading.meterType);
                });
                this.elements.meterTypes.textContent = uniqueMeterTypes.size;
                
                // Get latest reading
                if (this.readings.length > 0) {
                    const sortedReadings = [...this.readings].sort((a, b) => new Date(b.date) - new Date(a.date));
                    const latest = sortedReadings[0];
                    this.elements.latestReading.textContent = `${latest.value} ${latest.unit}`;
                    this.elements.lastUpdated.textContent = this.formatDate(latest.date);
                } else {
                    this.elements.latestReading.textContent = '-';
                    this.elements.lastUpdated.textContent = '-';
                }
                
                // Render recent readings
                const recentReadingsContainer = this.elements.recentReadings;
                if (this.readings.length > 0) {
                    const recentReadings = [...this.readings]
                        .sort((a, b) => new Date(b.date) - new Date(a.date))
                        .slice(0, 5);
                    
                    recentReadingsContainer.innerHTML = '';
                    recentReadings.forEach(reading => {
                        recentReadingsContainer.appendChild(this.createReadingElement(reading));
                    });
                } else {
                    recentReadingsContainer.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">📊</div>
                            <div class="empty-state-text">No readings yet</div>
                            <button class="btn" id="add-first-reading">Add Your First Reading</button>
                        </div>
                    `;
                    document.getElementById('add-first-reading').addEventListener('click', () => {
                        this.switchTab('add');
                    });
                }
                
                // Render chart
                this.renderChart();
            }

            renderReadings() {
                const allReadingsContainer = this.elements.allReadings;
                const filterValue = this.elements.filterMeterType.value;
                
                let filteredReadings = [...this.readings];
                
                // Apply filter if not "all"
                if (filterValue !== 'all') {
                    filteredReadings = filteredReadings.filter(reading => {
                        if (reading.meterType === 'custom') {
                            return reading.customMeterName === filterValue;
                        }
                        return reading.meterType === filterValue;
                    });
                }
                
                // Sort by date (newest first)
                filteredReadings.sort((a, b) => new Date(b.date) - new Date(a.date));
                
                if (filteredReadings.length > 0) {
                    allReadingsContainer.innerHTML = '';
                    filteredReadings.forEach(reading => {
                        allReadingsContainer.appendChild(this.createReadingElement(reading));
                    });
                } else {
                    allReadingsContainer.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">📊</div>
                            <div class="empty-state-text">No readings yet</div>
                            <button class="btn" id="add-reading-from-list">Add Your First Reading</button>
                        </div>
                    `;
                    document.getElementById('add-reading-from-list').addEventListener('click', () => {
                        this.switchTab('add');
                    });
                }
            }

            createReadingElement(reading) {
                const element = document.createElement('div');
                element.className = 'reading-item';
                
                // Determine meter type display name
                let meterTypeDisplay = '';
                if (reading.meterType === 'custom') {
                    meterTypeDisplay = reading.customMeterName;
                } else {
                    meterTypeDisplay = this.formatMeterType(reading.meterType);
                }
                
                element.innerHTML = `
                    <div class="reading-info">
                        <div><strong>${reading.name}</strong> (${meterTypeDisplay})</div>
                        <div class="reading-value">${reading.value} ${reading.unit}</div>
                        <div class="reading-date">${this.formatDate(reading.date)}</div>
                        ${reading.notes ? `<div class="reading-notes">${reading.notes}</div>` : ''}
                    </div>
                    <div class="reading-actions">
                        <button class="action-btn edit" data-id="${reading.id}">✏️</button>
                        <button class="action-btn delete" data-id="${reading.id}">🗑️</button>
                    </div>
                `;
                
                // Add event listeners
                element.querySelector('.edit').addEventListener('click', (e) => {
                    this.openEditModal(e.target.dataset.id);
                });
                
                element.querySelector('.delete').addEventListener('click', (e) => {
                    this.confirmDelete(e.target.dataset.id);
                });
                
                return element;
            }

            renderChart() {
                // Destroy existing chart if it exists
                if (this.chart) {
                    this.chart.destroy();
                }
                
                if (this.readings.length === 0) {
                    return;
                }
                
                // Group readings by meter name
                const meterGroups = {};
                this.readings.forEach(reading => {
                    if (!meterGroups[reading.name]) {
                        meterGroups[reading.name] = [];
                    }
                    meterGroups[reading.name].push({
                        date: new Date(reading.date),
                        value: parseFloat(reading.value),
                        unit: reading.unit
                    });
                });
                
                // Prepare chart data
                const datasets = [];
                const colors = [
                    '#4361ee', '#3a0ca3', '#4cc9f0', '#2ec4b6', 
                    '#ff9f1c', '#e71d36', '#6c757d', '#1a1a2e'
                ];
                
                let colorIndex = 0;
                for (const meterName in meterGroups) {
                    // Sort by date
                    const readings = meterGroups[meterName].sort((a, b) => a.date - b.date);
                    
                    // Get unit from first reading
                    const unit = readings[0].unit;
                    
                    datasets.push({
                        label: `${meterName} (${unit})`,
                        data: readings.map(r => ({ x: r.date, y: r.value })),
                        borderColor: colors[colorIndex % colors.length],
                        backgroundColor: colors[colorIndex % colors.length] + '33',
                        tension: 0.3,
                        pointRadius: 4,
                        pointHoverRadius: 6
                    });
                    
                    colorIndex++;
                }
                
                // Create chart
                this.chart = new Chart(this.elements.readingsChart, {
                    type: 'line',
                    data: {
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'day',
                                    displayFormats: {
                                        day: 'MMM d'
                                    }
                                },
                                title: {
                                    display: true,
                                    text: 'Date'
                                }
                            },
                            y: {
                                beginAtZero: false,
                                title: {
                                    display: true,
                                    text: 'Reading Value'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                position: 'top',
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(tooltipItems) {
                                        return new Date(tooltipItems[0].raw.x).toLocaleDateString();
                                    }
                                }
                            }
                        }
                    }
                });
            }

            updateFilterOptions() {
                const filterSelect = this.elements.filterMeterType;
                
                // Save current selection
                const currentValue = filterSelect.value;
                
                // Clear options except "All"
                while (filterSelect.options.length > 1) {
                    filterSelect.remove(1);
                }
                
                // Get unique meter types
                const meterTypes = new Set();
                this.readings.forEach(reading => {
                    if (reading.meterType === 'custom') {
                        meterTypes.add(reading.customMeterName);
                    } else {
                        meterTypes.add(reading.meterType);
                    }
                });
                
                // Add options
                meterTypes.forEach(type => {
                    const option = document.createElement('option');
                    option.value = type;
                    option.textContent = this.formatMeterType(type);
                    filterSelect.appendChild(option);
                });
                
                // Restore selection if possible
                if (Array.from(filterSelect.options).some(opt => opt.value === currentValue)) {
                    filterSelect.value = currentValue;
                } else {
                    filterSelect.value = 'all';
                }
            }

            // UI Event Handlers
            initializeTabs() {
                this.elements.tabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        const tabName = tab.dataset.tab;
                        this.switchTab(tabName);
                    });
                });
            }

            switchTab(tabName) {
                this.currentTab = tabName;
                
                // Update tab active state
                this.elements.tabs.forEach(tab => {
                    if (tab.dataset.tab === tabName) {
                        tab.classList.add('active');
                    } else {
                        tab.classList.remove('active');
                    }
                });
                
                // Update content visibility
                this.elements.tabContents.forEach(content => {
                    if (content.id === tabName) {
                        content.classList.add('active');
                    } else {
                        content.classList.remove('active');
                    }
                });
                
                // Special handling for add tab
                if (tabName === 'add') {
                    this.setCurrentDateTime();
                }
            }

            initializeFormHandlers() {
                // Add reading form
                this.elements.addReadingForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleAddReadingSubmit();
                });
                
                // Edit reading form
                this.elements.editReadingForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleEditReadingSubmit();
                });
                
                // Custom meter type handling
                this.elements.meterTypeSelect.addEventListener('change', () => {
                    this.toggleCustomMeterField(
                        this.elements.meterTypeSelect.value, 
                        this.elements.customMeterContainer
                    );
                });
                
                this.elements.editMeterTypeSelect.addEventListener('change', () => {
                    this.toggleCustomMeterField(
                        this.elements.editMeterTypeSelect.value, 
                        this.elements.editCustomMeterContainer
                    );
                });
                
                // Filter change
                this.elements.filterMeterType.addEventListener('change', () => {
                    this.renderReadings();
                });
            }

            initializeModalHandlers() {
                // Edit modal
                this.elements.editModalClose.addEventListener('click', () => {
                    this.closeEditModal();
                });
                
                // Import modal
                this.elements.importModalClose.addEventListener('click', () => {
                    this.closeImportModal();
                });
                
                this.elements.confirmImport.addEventListener('click', () => {
                    this.handleImportConfirm();
                });
                
                // Confirmation modal
                this.elements.confirmModalClose.addEventListener('click', () => {
                    this.closeConfirmModal();
                });
                
                this.elements.confirmYes.addEventListener('click', () => {
                    if (this.confirmCallback) {
                        this.confirmCallback();
                    }
                    this.closeConfirmModal();
                });
                
                this.elements.confirmNo.addEventListener('click', () => {
                    this.closeConfirmModal();
                });
            }

            initializeSettingsHandlers() {
                // Export data
                this.elements.exportData.addEventListener('click', () => {
                    this.exportDataToJson();
                });
                
                // Import data
                this.elements.importData.addEventListener('click', () => {
                    this.openImportModal();
                });
                
                // Clear data
                this.elements.clearData.addEventListener('click', () => {
                    this.confirmClearData();
                });
                
                // Theme toggle
                this.elements.themeToggle.addEventListener('change', () => {
                    this.toggleTheme();
                });
            }

            initializeTheme() {
                // Check saved theme preference
                const darkMode = localStorage.getItem('darkMode') === 'true';
                if (darkMode) {
                    document.body.classList.add('dark-mode');
                    this.elements.themeToggle.checked = true;
                }
            }

            toggleTheme() {
                const isDarkMode = this.elements.themeToggle.checked;
                if (isDarkMode) {
                    document.body.classList.add('dark-mode');
                } else {
                    document.body.classList.remove('dark-mode');
                }
                localStorage.setItem('darkMode', isDarkMode);
            }

            // Form Handling
            handleAddReadingSubmit() {
                const meterType = this.elements.meterTypeSelect.value;
                let customMeterName = '';
                
                if (meterType === 'custom') {
                    customMeterName = document.getElementById('custom-meter-name').value.trim();
                    if (!customMeterName) {
                        this.showToast('Please enter a custom meter name', 'error');
                        return;
                    }
                }
                
                const reading = {
                    meterType: meterType,
                    customMeterName: customMeterName,
                    name: document.getElementById('meter-name').value.trim(),
                    value: parseFloat(document.getElementById('reading-value').value),
                    unit: document.getElementById('reading-unit').value.trim(),
                    date: document.getElementById('reading-date').value,
                    notes: document.getElementById('reading-notes').value.trim()
                };
                
                this.addReading(reading);
                
                // Reset form
                this.elements.addReadingForm.reset();
                this.setCurrentDateTime();
                this.elements.customMeterContainer.style.display = 'none';
                
                // Switch to readings tab
                this.switchTab('readings');
            }

            handleEditReadingSubmit() {
                const meterType = this.elements.editMeterTypeSelect.value;
                let customMeterName = '';
                
                if (meterType === 'custom') {
                    customMeterName = document.getElementById('edit-custom-meter-name').value.trim();
                    if (!customMeterName) {
                        this.showToast('Please enter a custom meter name', 'error');
                        return;
                    }
                }
                
                const updatedReading = {
                    meterType: meterType,
                    customMeterName: customMeterName,
                    name: document.getElementById('edit-meter-name').value.trim(),
                    value: parseFloat(document.getElementById('edit-reading-value').value),
                    unit: document.getElementById('edit-reading-unit').value.trim(),
                    date: document.getElementById('edit-reading-date').value,
                    notes: document.getElementById('edit-reading-notes').value.trim()
                };
                
                const success = this.updateReading(this.editingReadingId, updatedReading);
                if (success) {
                    this.closeEditModal();
                }
            }

            handleImportConfirm() {
                const fileInput = this.elements.importFile;
                const importOption = document.querySelector('input[name="import-option"]:checked').value;
                
                if (!fileInput.files || fileInput.files.length === 0) {
                    this.showToast('Please select a file to import', 'error');
                    return;
                }
                
                const file = fileInput.files[0];
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    const success = this.importDataFromJson(e.target.result, importOption);
                    if (success) {
                        this.closeImportModal();
                    }
                };
                
                reader.onerror = () => {
                    this.showToast('Error reading file', 'error');
                };
                
                reader.readAsText(file);
            }

            // Modal Management
            openEditModal(readingId) {
                this.editingReadingId = readingId;
                const reading = this.readings.find(r => r.id === readingId);
                
                if (!reading) {
                    this.showToast('Reading not found', 'error');
                    return;
                }
                
                // Fill form with reading data
                document.getElementById('edit-meter-type').value = reading.meterType;
                document.getElementById('edit-meter-name').value = reading.name;
                document.getElementById('edit-reading-value').value = reading.value;
                document.getElementById('edit-reading-unit').value = reading.unit;
                document.getElementById('edit-reading-date').value = reading.date;
                document.getElementById('edit-reading-notes').value = reading.notes || '';
                
                // Handle custom meter type
                if (reading.meterType === 'custom') {
                    document.getElementById('edit-custom-meter-container').style.display = 'block';
                    document.getElementById('edit-custom-meter-name').value = reading.customMeterName;
                } else {
                    document.getElementById('edit-custom-meter-container').style.display = 'none';
                }
                
                // Show modal
                this.elements.editModal.classList.add('active');
            }

            closeEditModal() {
                this.elements.editModal.classList.remove('active');
                this.editingReadingId = null;
                this.elements.editReadingForm.reset();
            }

            openImportModal() {
                this.elements.importModal.classList.add('active');
            }

            closeImportModal() {
                this.elements.importModal.classList.remove('active');
                this.elements.importFile.value = '';
            }

            confirmDelete(readingId) {
                this.confirmCallback = () => {
                    this.deleteReading(readingId);
                };
                
                this.elements.confirmTitle.textContent = 'Delete Reading';
                this.elements.confirmMessage.textContent = 'Are you sure you want to delete this reading? This action cannot be undone.';
                this.elements.confirmModal.classList.add('active');
            }

            confirmClearData() {
                this.confirmCallback = () => {
                    this.clearAllData();
                };
                
                this.elements.confirmTitle.textContent = 'Clear All Data';
                this.elements.confirmMessage.textContent = 'Are you sure you want to delete ALL readings? This action cannot be undone.';
                this.elements.confirmModal.classList.add('active');
            }

            closeConfirmModal() {
                this.elements.confirmModal.classList.remove('active');
                this.confirmCallback = null;
            }

            // Utility Methods
            setCurrentDateTime() {
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                
                const dateTimeValue = `${year}-${month}-${day}T${hours}:${minutes}`;
                
                document.getElementById('reading-date').value = dateTimeValue;
            }

            formatDate(dateString) {
                const date = new Date(dateString);
                return date.toLocaleString();
            }

            formatMeterType(type) {
                if (!type) return '';
                
                // Handle predefined types
                const typeMap = {
                    'bike': 'Bike Odometer',
                    'bicycle': 'Bicycle Distance',
                    'electric': 'Electric Meter',
                    'water': 'Water Meter',
                    'gas': 'Gas Meter'
                };
                
                return typeMap[type] || type;
            }

            toggleCustomMeterField(meterType, container) {
                if (meterType === 'custom') {
                    container.style.display = 'block';
                } else {
                    container.style.display = 'none';
                }
            }

            showToast(message, type = 'info') {
                const toast = this.elements.toast;
                const toastMessage = this.elements.toastMessage;
                const toastIcon = this.elements.toastIcon;
                
                // Set message
                toastMessage.textContent = message;
                
                // Set type
                toast.className = 'toast';
                toast.classList.add(type);
                
                // Set icon
                switch (type) {
                    case 'success':
                        toastIcon.textContent = '✓';
                        break;
                    case 'error':
                        toastIcon.textContent = '✗';
                        break;
                    case 'warning':
                        toastIcon.textContent = '⚠';
                        break;
                    default:
                        toastIcon.textContent = 'ℹ';
                }
                
                // Show toast
                toast.classList.add('show');
                
                // Hide after 3 seconds
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 3000);
            }
        }
    </script>
</body>
</html>
